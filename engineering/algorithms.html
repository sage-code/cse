<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="description" content="An introduction to common software algorithms, their properties, and efficiency.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="software, engineering, algorithms, sorting, searching, complexity, big o">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

  <!-- Website title -->
  <title>Programming Algorithms</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="/prism.css">
  <script src="/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="/sage.css">
</head>
<body>

<div class="container">
        
<header id="dynamic-header" class="container-fluid pb-2"></header>

<div class="container-fluid px-0">
  <div class="row g-0">
    <aside class="side-bar col-lg-3 col-12">
      <div id="study-sidebar" class="sidebar-content shadow-sm p-1 sticky-top">
        <h5>Study Progress</h5>
        <div class="progress mb-3" style="height: 8px;">
          <div id="main-progress" class="progress-bar bg-success" style="width: 0%;"></div>
        </div>
        <hr>
        <ul id="bookmark-list" class="list-unstyled">
          <li><input type="checkbox" class="topic-check" data-target="intro"><a href="#intro">Introduction</a></li>
          <li><input type="checkbox" class="topic-check" data-target="properties"><a href="#properties">Properties</a></li>
          <li><input type="checkbox" class="topic-check" data-target="quality"><a href="#quality">Quality Attributes</a></li>
          <li>
            <input type="checkbox" class="topic-check" data-target="categories"><a href="#categories">Algorithm Categories</a>
            <ul class="list-unstyled">
              <li><input type="checkbox" class="topic-check" data-target="sorting"><a href="#sorting">Sorting</a></li>
              <li><input type="checkbox" class="topic-check" data-target="searching"><a href="#searching">Searching</a></li>
              <li><input type="checkbox" class="topic-check" data-target="graph"><a href="#graph">Graph</a></li>
              <li><input type="checkbox" class="topic-check" data-target="dynamic"><a href="#dynamic">Dynamic Programming</a></li>
              <li><input type="checkbox" class="topic-check" data-target="greedy"><a href="#greedy">Greedy</a></li>
              <li><input type="checkbox" class="topic-check" data-target="divide"><a href="#divide">Divide & Conquer</a></li>
            </ul>
          </li>
          <li><input type="checkbox" class="topic-check" data-target="efficiency"><a href="#efficiency">Efficiency</a></li>
          <li><input type="checkbox" class="topic-check" data-target="future"><a href="#future">Future of Algorithms</a></li>
        </ul>
        <button id="open-sidebar" class="btn btn-primary d-lg-none fixed-bottom m-3 rounded-circle shadow-lg">
          <span style="font-size: 24px;">â˜°</span>
        </button>
      </div>
    </aside>

<main class="col-lg-9 col-12 order-2 order-lg-1">

<h1 id="intro">Programming Algorithms</h1>

<div class="alert alert-secondary shadow-sm">
An algorithm is a finite set of well-defined instructions or rules designed to solve a specific problem. It is a step-by-step procedure that takes a defined input, performs a sequence of operations, and produces a desired output.
</div>
<p>Algorithms are the backbone of computer science and are used in a vast range of applications, including data analysis, sorting, searching, cryptography, and artificial intelligence. Understanding algorithms is essential for developing efficient and effective software.</p>

<h2><a id="properties">Algorithm Properties</a></h2>
<p>A valid algorithm must exhibit several key properties. It must accept a well-defined input, which can be provided explicitly or generated automatically. It must also produce a clear output. Beyond input and output, a well-designed algorithm must be:</p>
<ul>
    <li><strong>Correct:</strong> It must produce the correct output for all valid inputs.</li>
    <li><strong>Finite:</strong> It must terminate after a finite number of steps.</li>
    <li><strong>Well-Defined:</strong> Each step must be precisely defined and unambiguous.</li>
    <li><strong>Efficient:</strong> It should solve the problem without using excessive time or memory resources.</li>
</ul>

<h2><a id="quality">Algorithm Quality</a></h2>
<p>The quality of an algorithm is measured by how well it performs across several key attributes. These attributes determine its suitability for real-world scenarios and are crucial for building reliable and maintainable software systems.</p>
<table class="table table-bordered table-striped table-dark">
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>Efficiency</td><td>Measures resource usage, primarily time (CPU) and space (memory), often expressed with Big O notation.</td></tr>
    <tr><td>Accuracy</td><td>Refers to how precise or correct the algorithm's output is, crucial in numerical and machine learning algorithms.</td></tr>
    <tr><td>Maintainability</td><td>The ease with which an algorithm can be modified or adapted, often a result of clean, well-documented code.</td></tr>
    <tr><td>Robustness</td><td>The ability to handle unexpected or erroneous inputs gracefully without crashing.</td></tr>
    <tr><td>Scalability</td><td>How well the algorithm performs as the input size or system load increases.</td></tr>
    <tr><td>Security</td><td>The ability to protect data confidentiality, integrity, and availability from malicious actions.</td></tr>
    <tr><td>Usability</td><td>How easily the algorithm can be understood and used by developers.</td></tr>
    <tr><td>Portability</td><td>How easily the algorithm can be used in different environments or programming languages.</td></tr>
  </tbody>
</table>

<h2><a id="categories">Common Algorithm Categories</a></h2>
<p>When choosing an algorithm, developers consider problem constraints, required speed, and available resources. Often, a simple algorithm is implemented first and then optimized. Alternatively, a well-established algorithm known to work for similar problems can be adapted. Understanding the trade-offs between different approaches is key.</p> 

<h3 id="sorting">Sorting Algorithms</h3>
<p>Sorting algorithms are used to arrange elements of a list or array in a specific order (e.g., numerical or lexicographical). Examples include:</p>
<ul>
  <li><strong>Bubble Sort:</strong> A simple algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.</li>
  <li><strong>Merge Sort:</strong> A divide-and-conquer algorithm that divides the list into halves, sorts them, and then merges them back together.</li>
  <li><strong>Quick Sort:</strong> A highly efficient divide-and-conquer algorithm that picks an element as a pivot and partitions the array around the pivot.</li>
</ul>

<h3 id="searching">Searching Algorithms</h3>
<p>Searching algorithms are designed to retrieve a specific element from a data structure. Common examples include:</p>
<ul>
  <li><strong>Linear Search:</strong> Scans each item in a collection one by one until a match is found or the whole collection has been searched.</li>
  <li><strong>Binary Search:</strong> An efficient algorithm for finding an item from a <strong>sorted</strong> list by repeatedly dividing the search interval in half.</li>
</ul>

<h3 id="graph">Graph Algorithms</h3>
<p>Graph algorithms are designed to operate on graph data structures, which consist of vertices (nodes) and edges. They are used to solve problems related to networks.</p>
<ul>
  <li><strong>Depth-First Search (DFS):</strong> Traverses a graph by exploring as far as possible along each branch before backtracking.</li>
  <li><strong>Breadth-First Search (BFS):</strong> Traverses a graph by exploring all the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.</li>
  <li><strong>Dijkstra's Algorithm:</strong> Finds the shortest path between nodes in a weighted graph.</li>
</ul>

<h3 id="dynamic">Dynamic Programming</h3>
<p>Dynamic programming solves complex problems by breaking them down into simpler, overlapping sub-problems. It stores the solution to each sub-problem so it does not have to be recomputed, making it very efficient.</p>
<ul>
  <li><strong>Fibonacci Sequence:</strong> Can be efficiently computed by storing previously calculated numbers.</li>
  <li><strong>Knapsack Problem:</strong> A classic optimization problem to select items with the most value within a weight limit.</li>
</ul>

<h3 id="greedy">Greedy Algorithms</h3>
<p>A greedy algorithm makes the locally optimal choice at each step with the hope of finding a global optimum. It's a simpler approach that works well for many optimization problems, but does not guarantee the best solution for all problems.</p>
<ul>
  <li><strong>Huffman Coding:</strong> Used for creating efficient prefix codes for data compression.</li>
  <li><strong>Minimum Spanning Tree (e.g., Prim's, Kruskal's):</strong> Finds the lowest-cost way to connect all vertices in a graph.</li>
</ul>

<h3 id="divide">Divide and Conquer</h3>
<p>This paradigm involves breaking a problem into smaller sub-problems, solving each sub-problem recursively, and then combining the solutions to solve the original problem.</p>
<ul>
  <li><strong>Merge Sort & Quick Sort:</strong> Classic examples from sorting.</li>
  <li><strong>Binary Search:</strong> Works by repeatedly dividing the search space in half.</li>
</ul>

<h2><a id="efficiency">Algorithm Efficiency</a></h2>
<p>Efficiency is a critical measure of an algorithm's performance, typically analyzed in two main aspects:</p>
<ul>
  <li><strong>Time Complexity:</strong> The number of operations an algorithm takes to complete as a function of the input size (n). It describes how the runtime grows as 'n' grows.</li>
  <li><strong>Space Complexity:</strong> The amount of memory an algorithm uses, including input values and auxiliary space, as a function of the input size (n).</li>
</ul>
<p>Complexities are expressed using <strong>Big O notation</strong>, which describes the upper bound. Common complexities include O(1) [constant], O(log n) [logarithmic], O(n) [linear], O(n log n), O(n<sup>2</sup>) [quadratic], and O(2<sup>n</sup>) [exponential]. Efficient algorithms aim for low time and space complexities. However, optimizing one aspect can sometimes negatively impact the other, requiring a trade-off based on the specific problem and available resources.</p>

<table class="table table-bordered table-hover">
  <thead>
    <tr><th>Algorithm</th><th>Time Complexity (Avg)</th><th>Space Complexity (Worst)</th></tr>
  </thead>
  <tbody>
    <tr><td>Bubble Sort</td><td>O(n<sup>2</sup>)</td><td>O(1)</td></tr>
    <tr><td>Selection Sort</td><td>O(n<sup>2</sup>)</td><td>O(1)</td></tr>
    <tr><td>Merge Sort</td><td>O(n log n)</td><td>O(n)</td></tr>
    <tr><td>Quick Sort</td><td>O(n log n)</td><td>O(log n) - O(n)</td></tr>
    <tr><td>Binary Search</td><td>O(log n)</td><td>O(1)</td></tr>
    <tr><td>Breadth-First Search (BFS)</td><td>O(V+E)</td><td>O(V)</td></tr>
    <tr><td>Depth-First Search (DFS)</td><td>O(V+E)</td><td>O(V)</td></tr>
  </tbody>
</table>

<h2><a id="future">The Future of Algorithms</a></h2>
<p>Algorithms are at the heart of modern computing, and their importance continues to grow, especially with the rise of <strong>Artificial Intelligence (AI)</strong>. AI heavily relies on algorithms for tasks like decision-making, pattern recognition, and natural language processing. Popular AI algorithms include Neural Networks, Reinforcement Learning, and Decision Trees.</p>
<p>Future advancements are expected in areas like quantum computing, deep learning, and advanced AI. New algorithmic paradigms will be required to tackle even more challenging problems in fields like drug discovery, climate modeling, and space exploration. As algorithms become more integrated into our lives, their responsible design and ethical implications will become increasingly critical.</p>
<hr>

<p><b>Read next:</b> <a href="/engineering/paradigms/">Programming Paradigms</a></p>

</main>
  </div>
</div>

<!-- Footer -->
<footer class="footer copyright">
  <p class="x-small text-secondary mb-0">&copy; 2026 Sage-Code Laboratory</p>
</footer>
</div>
<script src="/sage.js" defer></script>
<script src="/sidebar.js" defer></script>
<script src="/progress.js" defer></script>
</body>
</html>
