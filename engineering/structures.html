<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="description" content="A comprehensive overview of fundamental data structures in software engineering.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="software, engineering, data, structures, array, list, stack, queue, tree, graph, hash, table">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Data Structures</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="/images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="/prism.css">
  <script src="/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="/sage.css">
</head>
<body>

<div class="container">
        
<header id="dynamic-header" class="container-fluid pb-2"></header>

<div class="container-fluid px-0">
  <div class="row g-0">
    <aside class="side-bar col-lg-3 col-12">
        <div id="study-sidebar" class="sidebar-content shadow-sm p-1 sticky-top">
        <h5>Study Progress</h5>
        <div class="progress mb-3" style="height: 8px;">
          <div id="main-progress" class="progress-bar bg-success" style="width: 0%;"></div>
        </div>
        <hr>
        <ul id="bookmark-list" class="list-unstyled">
          <li><input type="checkbox" class="topic-check" data-target="intro"><a href="#intro">Introduction</a></li>
          <li><input type="checkbox" class="topic-check" data-target="arrays"><a href="#arrays">Arrays</a></li>
          <li><input type="checkbox" class="topic-check" data-target="lists"><a href="#lists">Linked Lists</a></li>
          <li><input type="checkbox" class="topic-check" data-target="stacks"><a href="#stacks">Stacks</a></li>
          <li><input type="checkbox" class="topic-check" data-target="queues"><a href="#queues">Queues</a></li>
          <li><input type="checkbox" class="topic-check" data-target="heaps"><a href="#heaps">Heaps</a></li>
          <li><input type="checkbox" class="topic-check" data-target="trees"><a href="#trees">Trees</a></li>
          <li><input type="checkbox" class="topic-check" data-target="graphs"><a href="#graphs">Graphs</a></li>
          <li><input type="checkbox" class="topic-check" data-target="hash"><a href="#hash">Hash Tables</a></li>
          <li><input type="checkbox" class="topic-check" data-target="exotic"><a href="#exotic">Exotic Structures</a></li>
          <li><input type="checkbox" class="topic-check" data-target="strings"><a href="#strings">String Representation</a></li>
        </ul>
        <button id="open-sidebar" class="btn btn-primary d-lg-none fixed-bottom m-3 rounded-circle shadow-lg">
          <span style="font-size: 24px;">â˜°</span>
        </button>
      </div>
    </aside>

<main class="col-lg-9 col-12 order-2 order-lg-1">

<h1>Data Structures</h1>

<h2><a id="intro">Introduction</a></h2>
<div class="alert alert-secondary shadow-sm">
Data structures are specialized formats for organizing, processing, retrieving, and storing data in a computer's memory. They are chosen to efficiently perform operations for various algorithms and applications. In computer science, data structures are divided into two main categories:
</div>

<ul>
  <li><strong>Primitive Data Types:</strong> These are the most basic types, representing simple values like integers, floating-point numbers, characters, and booleans. They are the building blocks for more complex structures.</li>
  <li><strong>Abstract Data Types (ADTs):</strong> These are more complex structures that consist of both a set of data and a set of operations that can be performed on that data. ADTs, like linked lists, trees, and graphs, are defined by their behavior (what they do) rather than their specific implementation (how they do it).</li>
</ul>
<p>The choice of data structure is critical and depends on the specific problem being solved. Some structures offer fast access, some provide efficient insertion/deletion, and others are optimized for searching or memory usage.</p>
<hr>

<h2><a id="arrays">Arrays</a></h2>
<p>An array is a collection of elements, each identified by at least one array index or key. In most programming languages, arrays store elements of the same data type in contiguous memory locations, allowing for fast, indexed access.</p>
<strong>Features:</strong>
<ul>
  <li>Stores a homogeneous collection of elements.</li>
  <li>Elements are stored in contiguous memory locations, accessible via a 0-based index.</li>
  <li>Typically has a fixed size, defined upon creation.</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li><strong>O(1)</strong> time complexity for accessing elements by index.</li>
  <li>Memory efficient as it requires no extra storage for pointers or metadata.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Storing and accessing a collection of a known size.</li>
  <li>Implementing other data structures like stacks, queues, and hash tables.</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Insertion and deletion operations are slow (<strong>O(n)</strong>) because subsequent items must be shifted.</li>
  <li>Resizing is often an expensive operation that involves creating a new array and copying elements.</li>
</ul>
<hr>

<h2><a id="lists">Linked Lists</a></h2>
<p>A linked list is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element (node) contains data and a pointer to the next node in the sequence.</p>
<strong>Features:</strong>
<ul>
  <li>Can store a homogeneous or heterogeneous collection of elements.</li>
  <li>Elements are stored in non-contiguous memory locations.</li>
  <li>Comes in several varieties, including singly-linked, doubly-linked, and circular lists.</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li>Insertion and deletion are efficient (<strong>O(1)</strong>) if a pointer to the target node is already held.</li>
  <li>Dynamic in size, growing and shrinking as needed.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Implementing dynamic data structures where the number of items is unknown.</li>
  <li>Implementing stacks and queues.</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Accessing an element by index has linear time complexity (<strong>O(n)</strong>) as it requires traversing the list from the beginning.</li>
  <li>Requires extra memory to store pointers for each node.</li>
</ul>
<hr>

<h2><a id="stacks">Stacks</a></h2>
<p>A stack is a linear data structure that follows the <strong>LIFO (Last-In, First-Out)</strong> principle. Elements can be added (pushed) or removed (popped) only from the top of the stack.</p>
<strong>Features:</strong>
<ul>
  <li>Elements are accessed using LIFO ordering.</li>
  <li>Primary operations are `push` (add to top) and `pop` (remove from top).</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li>Simple to implement and use.</li>
  <li>Useful for reversing a sequence of elements.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Managing function calls (the call stack) in recursion.</li>
  <li>Implementing undo/redo functionality in software.</li>
  <li>Parsing expressions (e.g., checking for balanced parentheses).</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Accessing elements other than the top is inefficient.</li>
  <li>Stack size can be limited by available memory.</li>
</ul>
<hr>

<h2><a id="queues">Queues</a></h2>
<p>A queue is a linear data structure that follows the <strong>FIFO (First-In, First-Out)</strong> principle. Elements are inserted at the back (enqueue) and removed from the front (dequeue).</p>
<strong>Features:</strong>
<ul>
  <li>Elements are accessed using FIFO ordering.</li>
  <li>Primary operations are `enqueue` (add to rear) and `dequeue` (remove from front).</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li>Easy to implement and use.</li>
  <li>Fairly orders tasks or elements.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Managing tasks for a printer or CPU scheduling.</li>
  <li>Implementing a buffer for streaming data.</li>
  <li>Breadth-First Search (BFS) algorithms in graphs.</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Accessing elements other than the front is inefficient.</li>
</ul>
<hr>

<h2><a id="heaps">Heaps</a></h2>
<p>A heap is a specialized tree-based data structure that satisfies the heap property. In a <em>max-heap</em>, for any given node, the value is greater than or equal to the values of its children. In a <em>min-heap</em>, it is less than or equal to.</p>
<strong>Features:</strong>
<ul>
  <li>Typically implemented as a complete binary tree.</li>
  <li>Supports efficient insertion and removal of the minimum or maximum element.</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li>Finding the minimum or maximum element is very fast (<strong>O(1)</strong>).</li>
  <li>Insertion and deletion are efficient (<strong>O(log n)</strong>).</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Implementing priority queues.</li>
  <li>The Heapsort algorithm.</li>
  <li>Graph algorithms like Dijkstra's algorithm.</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Searching for an element other than the min/max is inefficient (<strong>O(n)</strong>).</li>
</ul>
<hr>

<h2><a id="trees">Trees</a></h2>
<p>A tree is a hierarchical data structure consisting of nodes connected by edges. It has a topmost node known as the root, and each node can have zero or more children nodes.</p>
<strong>Features:</strong>
<ul>
  <li>Represents hierarchical relationships.</li>
  <li>Common types include Binary Trees, Binary Search Trees (BSTs), and balanced trees (e.g., AVL, Red-Black Trees).</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li>In a balanced search tree, insertion, deletion, and search operations are very efficient (<strong>O(log n)</strong>).</li>
  <li>Naturally represents hierarchical data like file systems or organizational charts.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Implementing search algorithms (e.g., Binary Search Tree).</li>
  <li>Storing data for efficient retrieval (database indexing).</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Can be complex to implement correctly.</li>
  <li>In an unbalanced tree, performance can degrade to that of a linked list (<strong>O(n)</strong>).</li>
</ul>
<hr>

<h2><a id="graphs">Graphs</a></h2>
<p>A graph is a non-linear data structure consisting of a set of vertices (or nodes) connected by edges. Edges can be directed (one-way) or undirected (two-way) and may have weights associated with them.</p>
<strong>Features:</strong>
<ul>
  <li>Represents complex network relationships.</li>
  <li>Can be directed or undirected, weighted or unweighted, cyclic or acyclic.</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li>Ideal for modeling real-world networks like social connections, road maps, and the internet.</li>
  <li>Supports powerful traversal algorithms like Depth-First Search (DFS) and Breadth-First Search (BFS).</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Representing social networks.</li>
  <li>Pathfinding algorithms like Dijkstra's and A*.</li>
  <li>Modeling dependencies in tasks or computer networks.</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Can be difficult to implement and visualize.</li>
  <li>Many graph algorithms have high time complexity.</li>
</ul>
<hr>

<h2><a id="hash">Hash Tables</a></h2>
<p>A hash table is a data structure that implements an associative array, which maps keys to values. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.</p>
<strong>Features:</strong>
<ul>
  <li>Elements are accessed using key-value pairs.</li>
  <li>Uses a hash function to map keys to array indices.</li>
  <li>Requires a collision resolution strategy (e.g., chaining or open addressing).</li>
</ul>
<strong>Advantages:</strong>
<ul>
  <li>Extremely efficient insertion, deletion, and search operations on average (<strong>O(1)</strong>).</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Implementing dictionaries, maps, and sets in programming languages.</li>
  <li>Database indexing and caching.</li>
</ul>
<strong>Disadvantages:</strong>
<ul>
  <li>Worst-case time complexity can be slow (<strong>O(n)</strong>) if there are many hash collisions.</li>
  <li>Choosing a good hash function is critical for performance.</li>
</ul>
<hr>

<h2><a id="exotic">Exotic Structures</a></h2>
<div class="alert alert-secondary">Exotic data structures are less common structures designed to solve specific, complex problems with high efficiency. While not as widely used as arrays or lists, they are powerful tools for specialized applications.</div>

<h3><a id="bloom">Bloom filters</a></h3>
<p>A Bloom filter is a space-efficient probabilistic data structure used to test whether an element is a member of a set. It is designed to be extremely fast and memory-efficient.</p>
<strong>Features:</strong>
<ul>
  <li>Uses multiple hash functions to map an item to several bits in a bit array.</li>
  <li><strong>False positives are possible, but false negatives are not.</strong> If the filter says an item is not in the set, it is definitively not. If it says the item is in the set, it might be a false positive.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Checking for previously seen items, e.g., to avoid showing a user the same news article twice.</li>
  <li>Network routers use them to block malicious websites without storing a giant list.</li>
</ul>

<h3><a id="hyperloglog">HyperLogLog</a></h3>
<p>HyperLogLog is a probabilistic data structure used to estimate the number of distinct elements (the cardinality) in a set, using a very small and fixed amount of memory.</p>
<strong>Features:</strong>
<ul>
  <li>Provides a highly accurate cardinality estimate with minimal memory usage.</li>
  <li>Uses a hash function and statistical analysis of the resulting bit patterns.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Counting unique visitors to a website in real-time.</li>
  <li>Estimating the number of distinct words in a very large text corpus.</li>
</ul>

<h3><a id="interval-trees">Interval Trees</a></h3>
<p>An interval tree is a data structure for storing intervals and efficiently finding all intervals in the collection that overlap with a given query interval or point.</p>
<strong>Features:</strong>
<ul>
  <li>A tree structure where each node stores information about intervals.</li>
  <li>Provides a fast way to find all overlapping intervals.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Finding scheduling conflicts in a list of appointments.</li>
  <li>In genomics, finding all genes that overlap a specific DNA region.</li>
</ul>

<h3><a id="tries">Tries</a></h3>
<p>A trie (also known as a prefix tree) is a tree-like data structure that stores a dynamic set of strings, where the keys are usually strings. Nodes do not store keys; instead, an element's position in the tree defines the key with which it is associated.</p>
<strong>Features:</strong>
<ul>
  <li>Each node represents a common prefix of a set of keys.</li>
  <li>Very efficient for prefix-based searches.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Implementing autocomplete functionality in search engines.</li>
  <li>Serving as a dictionary for spell-checking.</li>
</ul>

<h3><a id="wavelet-trees">Wavelet trees</a></h3>
<p>A wavelet tree is a compact data structure for storing a sequence of symbols, enabling efficient queries on that sequence. It compresses the data while still allowing for fast ranking, selection, and access operations.</p>
<strong>Features:</strong>
<ul>
  <li>Compresses data by exploiting character frequencies.</li>
  <li>Answers complex queries (like "how many times does 'a' appear in the first 1000 characters?") in logarithmic time.</li>
</ul>
<strong>Use cases:</strong>
<ul>
  <li>Bioinformatics for analyzing genomic sequences.</li>
  <li>Full-text search and text indexing in large document databases.</li>
</ul>
<hr>

<h2><a id="strings">String Representation</a></h2>
<p>While strings are often a primitive type, their internal representation can be optimized using specialized data structures, especially for very large strings.</p>
<ul>
  <li><strong>Rope:</strong> A binary tree used to efficiently store and manipulate large strings. Concatenation and substring operations are much faster than with simple character arrays.</li>
  <li><strong>Array of Strings:</strong> A simple and effective method for a collection of many small, fixed-size strings.</li>
  <li><strong>Trie:</strong> As mentioned before, a trie is ideal for storing large numbers of strings that share common prefixes, like in a dictionary.</li>
  <li><strong>Hash Table:</strong> Can be used for fast string retrieval and ensuring uniqueness in a collection of strings.</li>
  <li><strong>Suffix Array/Tree:</strong> Advanced structures used for complex substring searches. They store all suffixes of a string in a sorted manner, enabling extremely fast lookups. Useful in text compression and bioinformatics.</li>
</ul>
<p>The choice of which data structure to use depends on the specific requirements of the application, such as the size and number of strings, the operations needed, and the available memory.</p>
<hr>

<p><b>Read next:</b> <a href="/engineering/algorithms/">Algorithms</a></p>

</main>
  </div>
</div>

<!-- Footer -->
<footer class="footer copyright">
  <p class="x-small text-secondary mb-0">&copy; 2026 Sage-Code Laboratory</p>
</footer>
</div>
<script src="/sage.js" defer></script>
<script src="/sidebar.js" defer></script>
<script src="/progress.js" defer></script>
</body>
</html>
