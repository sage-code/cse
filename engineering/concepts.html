<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Fundamental concepts of computer programming.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="programming, fundamental, concepts, basic, beginners, logic, numeric, expressions">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>SC Concepts</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="/images/favicon.ico">
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="/prism.css">
  <script src="/prism.js"></script>
  <!-- custom css -->
  <link rel="stylesheet" href="/sage.css">
  </head>
<body>

<div class="container">

<!-- header -->
<header id="dynamic-header" class="container-fluid pb-2"></header>

<!-- sidebar -->
<div class="container-fluid px-0">
  <div class="row g-0">
    <aside class="side-bar col-lg-3 col-12">
      <div id="study-sidebar" class="sidebar-content shadow-sm p-3 sticky-top">
        <h5>Study Progress</h5>
        <div class="progress mb-3" style="height: 8px;">
          <div id="main-progress" class="progress-bar bg-success" style="width: 0%;"></div>
        </div>

        <hr>
        
        <ul id="bookmark-list" class="list-unstyled">
          <li class="nav-item mb-2">
            <input type="checkbox" class="topic-check" data-target="programs"> 
            <a href="#programs" class="fw-bold">Computer programs</a>
            <ul class="list-unstyled ms-4 mt-1">
               <li class="nav-item"><input type="checkbox" class="topic-check" data-target="app-purpose"> <a href="#app-purpose">Application purpose</a></li>
               <li class="nav-item"><input type="checkbox" class="topic-check" data-target="app-execution"> <a href="#app-execution">Application execution</a></li>
               <li class="nav-item"><input type="checkbox" class="topic-check" data-target="code-base"> <a href="#code-base">Code base</a></li>
            </ul>
          </li>

          <li class="nav-item mb-2">
            <input type="checkbox" class="topic-check" data-target="symbols"> 
            <a href="#symbols" class="fw-bold">Programming symbols</a>
          </li>

          <li class="nav-item mb-2">
            <input type="checkbox" class="topic-check" data-target="logic"> 
            <a href="#logic" class="fw-bold">Logic science</a>
            <ul class="list-unstyled ms-4 mt-1">
              <li class="nav-item"><input type="checkbox" class="topic-check" data-target="prop-logic"> <a href="#prop-logic">Propositional Logic</a></li>
              <li class="nav-item"><input type="checkbox" class="topic-check" data-target="boolean"> <a href="#boolean">Boolean algebra</a></li>
              <li class="nav-item"><input type="checkbox" class="topic-check" data-target="predicate-logic"> <a href="#predicate-logic">Predicate Logic</a></li>
            </ul>
          </li>

          <li class="nav-item mb-2"> <input type="checkbox" class="topic-check" data-target="list-sets"> <a href="#list-sets" class="fw-bold">Lists & Sets</a></li>
          <li class="nav-item mb-2"> <input type="checkbox" class="topic-check" data-target="machines"> <a href="#machines" class="fw-bold">State Machines</a></li>
          <li class="nav-item mb-2"> <input type="checkbox" class="topic-check" data-target="turing-machine"> <a href="#turing-machine" class="fw-bold">Turing Machine</a></li>
          <li class="nav-item mb-2"> <input type="checkbox" class="topic-check" data-target="inteligence"> <a href="#inteligence" class="fw-bold">Artificial Intelligence</a></li>
        </ul>
      </div>
    </aside>

<!-- main content --> 
<main class="col-lg-9 col-12 order-2 order-lg-1">

<h1>Programming Concepts</h1>

<div class="alert alert-secondary shadow-sm">
This article is intended for those new to computer science. We begin by exploring the fundamental concepts that form the foundation of programming and software engineering. These concepts are essential for creating new software, solving problems, and supporting business operations. Understanding them will help you build a strong base for further study and creation of practical applications.</div>

<hr>

<h2><a id="programs">Computer programs</a></h2>

<div class="alert alert-secondary shadow-sm">
Computer programs, often called applications, are fundamentally a series of step-by-step instructions executed by a computer. These instructions are organized into statements, which are then grouped into modules or packages. A single program can consist of numerous packages and may include embedded data or rely on external files for data storage.
</div>

<h3 id="app-purpose">Application Purpose</h3>

<p>Applications are built using one or more programming languages and are typically designed to solve a specific problem. They often include multiple features that allow users to interact with the system, sending or receiving information through input/output devices such as a console display or a printer.</p>

<h3 id="app-execution">Application Execution</h3>

<p>The execution of a program aims to resolve a problem and communicate the result, or it can produce a physical effect, such as displaying a message on a monitor or controlling a robotic arm. A program can be designed to be executed a single time or multiple times as needed.</p>

<h3 id="code-base">Code base</h3>

<p>Computer programs consist of files stored in folders, which we call a "project" or <em>code base</em>. A project contains text files with language-specific extensions (source code), and may also include data files, images, audio, and video. Usually, one file is designated as the main entry point that utilizes the other files. A project should also contain documentation.</p>


<h3>Sub-programs</h3>

<div class="alert alert-secondary shadow-sm">Sub-programs serve the principle of "separation of concerns," meaning each sub-program is designed to do one small task. The main program then combines the effects of multiple sub-programs to implement the system's end-to-end functionality. Sub-programs can be contained within a larger program or delivered as reusable components or libraries.</div>

<p>Depending on the computer language, sub-programs are called sub-routines, procedures, functions, methods, or rules. What they have in common is that they all encapsulate specific functionality. The main program orchestrates the execution of sub-programs by transferring control to sub-processes, which can be executed synchronously or asynchronously (sometimes in parallel).</p>

<h3>Formal parameters</h3>

<div class="alert alert-secondary shadow-sm">Sub-programs can receive parameters and can compute results. Sometimes we call these "formal parameters" or "receiver variables". Usually parameters for sub-programs are immutable during sub-program execution.</div>

<p>Parameters are similar to local variables. They are known only inside the sub-routine. Once the subroutine is finished, the value of the parameters is lost or can be propagated back to the caller. This depends on the declaration syntax and purpose of the parameter.</p>

<h3>Subprogram Results</h3>

<p>A subprogram can produce one or more results, which are returned to the part of the program that initiated the call. This is often accomplished using a <code>return</code> statement. The data type of the result must match the type declared in the subprogram's signature. Some subprograms, known as procedures or void functions, do not return a value and are executed only for their side effects, such as printing to a console or modifying a file.</p>


<h2><a id="symbols">Programming Symbols</a></h2>

<p>A program is made of symbols that are used to create expressions. Most languages are using expressions that are similar to the ones we learn in mathematics. Sometimes beginners have hard time understanding the difference between "expressions", "symbols" and relation with "functions". We will explain these things here.</p>

<p>Symbols can be single character or multi-character. Single character symbols can be {"digits", "letters", "ASCII", "UNICODE"}. We use symbols to create: operators, punctuation marks, numeric literals, string literals, identifiers, enumerations and data collections.</p>

<p>In general a program manipulate "data". This is also made of symbols. We learn in school to count using Arabic digital symbols: 0,1,2,3,4,5,6,7,8,9. We also learn how to read and write text using Latin alphabet: Aa, Bb, Cc, Dd, Ee, Ff, Gg ... Zz. This is not the case in all cultures around the globe. Some cultures are using other symbols to represent data.</p>

<h4>Encoding</h4>

<p>The way we represent data using the symbols is called <em>encoding</em>. The most popular encoding system known as Unicode. Before Unicode was invented we used different encodings system known as: ASCII. For different countries there is an Extended ASCII table that has diacritics and special characters. Also Unicode have several variations: UTF16, UTF32 and UTF8.</p>

<h4>Binary</h4>

<p>A computer uses binary representations of "1" and "0" for encoding symbols. The "1" typically represents a positive electrical charge, while "0" represents no charge. It is similar to a light bulb: when the light is on, we can consider it to represent the logical value "1"; when the light is off, we consider it to represent "0".</p>

<h4>Storage</h4>

<p>Electronic devices store data using specialized components. There are several physical methods, including "electro-static," "electro-magnetic," "optic," "magneto-optic," and "solid-state electronics." The fundamental point is that all modern computation is digital and based on a binary system.</p>

<h2><a id="logic">Logic Science</a></h2>

<div class="alert alert-secondary shadow-sm">
<p>Logic was discovered by the ancient Greeks and formalized by Aristotle. The word itself means "thought" or "reason." Initially a branch of philosophy, it has since evolved into a formal branch of mathematics. Logic is the science of truth, and its purpose is to provide a framework for reasoning.</p>
</div>

<h3>Fundamental Concepts</h3>

<p>To understand logic, we must first define some foundational words and rules. A firm grasp of these definitions is essential for having meaningful conversations and making sound arguments in computer science. This section provides an introduction to these core concepts.</p>

<h4>Inference</h4>

<p>Inference, also known as <em>deduction</em> or <em>implication</em>, is a core concept in logic. It is the conclusion reached after studying the arguments or premises within a sentence. Inference is a fundamental method of thinking and reasoning.</p>

<div class="alert alert-info shadow-sm"><span class="text-brown">Logical Inference:&nbsp;</span>Using valid arguments in a sentence allows us to derive a logical conclusion. Sound arguments will produce the same conclusion regardless of who makes the arguments or derives the conclusion.</div>

<p>Inference and reason may not operate the same way in all contexts. For example, individuals from different philosophical or religious backgrounds might interpret a sentence in different ways, leading to different conclusions.</p>

<h4>Sentences</h4> 

<p>Sentences are sequences of words that together express an idea, describe a situation, give a command, or make an inquiry. Sentences can be classified into four main categories:</p>

<ul>
<li>Imperative sentences (orders/commands)</li>
<li>Interrogative sentences (inquiries)</li>
<li>Declarative sentences (statements)</li>
<li>Exclamatory sentences (expressing surprise)</li>
</ul>

<h4>Elements</h4> 

<p>A sentence can have five elements: { subject, verb, object, complement, and adjunct } (SVOCA). The subject is the performer of an action. It usually appears at the beginning of a sentence and is represented by a noun or its equivalent (e.g., a pronoun, a noun phrase). The study of sentence structure is known as grammar.</p>

<h4>Statements</h4> 

<p><em>Statements</em> are declarative sentences that express a fact, idea, or opinion. Statements do not make requests, give commands, or express surprise. A statement usually ends with a period (.).</p>

<p>Some statements are neither true nor false but have an undetermined value, such as “maybe” or “probable.” There is a special branch of logic for handling such statements.</p>

<h4>Propositions</h4> 

<p><em>Propositions</em> are statements that can be either true or false, but not both at the same time. Propositions are the building blocks of propositional logic.</p>

<p>There are examples of declarative sentences that are not propositions. For example, the sentence “This sentence is false” is a well-known paradox. If we assign it the truth value 'True,' we imply the sentence is false. If we assign it 'False,' we imply the sentence is not false, creating a contradiction.</p>

<h4>Fundamental principle</h4>

<p>It is important to know that formal logic derives valid inferences from declarative sentences, not from imperative or interrogative ones. An imperative sentence is a command from an authority, such as a ruler, government, or deity.</p>

<div class="alert alert-danger shadow-sm"><span class="text-brown">Info:&nbsp;</span>Drawing inferences from imperative sentences can lead to irrational beliefs, unjust laws, and social injustice. Logic must be based on facts and solid arguments, not on commands that bypass reason.</div>

<h4>Composition rules</h4>

<p>Statements can be simple or composite. Composite statements can include arguments. A composite statement is made of simple statements. Most statements are true or false.</p>

<p>Let's say we have an argument or a premise and a sentence. Following are some logic rules that can apply to these two:</p>
<ul>
<li><b>Identity rule:</b>&nbsp;An argument is identical with itself and not something else;</li>
<li><b>Contradiction rule:</b>&nbsp;An argument cannot be true and false in same sentence;</li>
<li><b>Validity rule:</b>&nbsp;An argument is valid if the truth of premises lead to truth of the conclusion.</li>
</ul>

<h3>Validity and Soundness</h3>

<div class="alert alert-secondary shadow-sm">A deductive argument is said to be valid if takes a form that makes it impossible for the premises to be true and the conclusion nevertheless to be false. Otherwise, a deductive argument is said to be invalid.</div>

<p>A deductive argument is sound if and only if it is both valid, and all of its premises are true. Otherwise, a deductive argument is unsound. Unsound arguments are invalid.</p>

<h2><a id="prop-logic">Propositional Logic</a></h2>

<div class="alert alert-secondary shadow-sm">Propositional logic studies the relationships between declarative sentences (propositions). These propositions can have Boolean values of True or False. This branch of logic does not concern itself with the content of the propositions, but only with the logical relationships between them.</div>

<p>In these rules, we use variables like A, B, and P to represent logical propositions. The core of propositional logic involves operators like AND, OR, and NOT, which have precise rules that make it a reliable and foundational theory in computer science.</p>

<h4>Fundamental rules:</h4>

<p>Several logical rules are universal and cannot be broken, regardless of culture or language. Understanding these rules is a crucial first step toward understanding computer science.</p>

<ul>
<li>If A and B are both true, then P = A and B is true.</li>
<li>If either A or B (or both) are false, then P = A and B is false.</li>
<li>If either A or B (or both) are true, then P = A or B is true.</li>
<li>If both A and B are false, then P = A or B is false.</li>
<li>If A is true, then P = not A is false.</li>
<li>If A is false, then P = not A is true.</li>
</ul>

<p>Additionally, the "or" and "and" operators are commutative, meaning the order of the propositions does not affect the result:</p>

<ul>
<li>(A and B) is equivalent to (B and A)</li>
<li>(A or B) is equivalent to (B or A)</li>
</ul>

<h4>De Morgan's laws:</h4>

<p>Sometimes, you can transform one logical expression into an equivalent one without knowing the value of the arguments. These rules, known as De Morgan's laws, are very useful in computer science for optimizing Boolean expressions.</p>

<ul>
<li>The negation of a disjunction is the conjunction of the negations.</li>
<li>The negation of a conjunction is the disjunction of the negations.</li>
</ul>

<p>In terms of expressions, this means:</p>

<ul>
<li>not (not A) == A (Double Negation)</li>
<li>not (A or B) == (not A) and (not B)</li>
<li>not (A and B) == (not A) or (not B)</li>
</ul>


<h2><a id="boolean">Boolean algebra</a></h2>

<p>Boolean algebra is the branch of algebra in which the values of the variables are the truth values true and false, usually denoted 1 and 0 respectively. This contrasts with general algebra that study other numbers not only the value 1 and 0.</p>

<h4>Logical Operations:</h4>
<p>I have found these are the most suitable symbols for logical operators. Though no programming language yet uses them.</p>
<table class="table table-striped table-bordered table-dark">
<thead>
<tr>
<th>symbol</th>
<th>alternative</th>
<th>meaning</th>
<th>notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>&not;</td>
<td>!</td>
<td>NOT</td>
<td>negation</td>
</tr>
<tr>
<td>&and;</td>
<td>&amp;</td>
<td>AND</td>
<td>conjunction</td>
</tr>
<tr>
<td>&or;</td>
<td>|</td>
<td>OR</td>
<td>disjunction</td>
</tr>
<tr>
<td>&oplus;</td>
<td>^</td>
<td>XOR</td>
<td>exclusive disjunction</td>
</tr>
<tr>
<td>&darr;</td>
<td>&nbsp;</td>
<td>NOR</td>
<td>p &darr; q = &not; (p &or; q)</td>
</tr>
<tr>
<td>&uarr;</td>
<td>&nbsp;</td>
<td>NAND</td>
<td>p &uarr; q = &not; (p &and; q)</td>
</tr>
</tbody>
</table>

<h4>The table of truth:</h4>

<p>Next table shows all possible combinations and the result for logical operators.</p>
<table class="table table-striped table-bordered table-dark">
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>&not; p</th>
<th>&not; q</th>
<th>p &oplus; q</th>
<th>p &and; q</th>
<th>p &or; q</th>
</tr>
</thead>
<tbody>
<tr>
<th>1</th>
<th>1</th>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<th>1</th>
<th>0</th>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<th>0</th>
<th>1</th>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<th>0</th>
<th>0</th>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

<h2><a id="predicate-logic">Predicate logic</a></h2>

<div class="alert alert-secondary shadow-sm">
Predicate logic is an extension of propositional logic. In propositional logic we look at propositions and arguments. That can be true or false but in reality there are many other things that are not true or false. In predicate logic we use terms and relations between terms to establish the value of truth of a proposition. Predicate logic is essential in programming, to deal with numbers and data sets.</div>

<h4>Use case</h4>

<p>Predicate logic define new terminology and notations. Understanding this terminology will help you read complex documentation used in programming. This may be a language specification or high level requirement that you can receive on the job. You can be invited to elaborate the requirements in detailed design that require logic.</p>

<h4>Predicate</h4>

<p>A predicate is a property or a relation between one or more terms. One term can be a variable or a constant. A predicate is not a logic entity but it can be evaluated to value True, False or invalid, depending on the range of predicate arguments.</p>

<p>Predicates with one argument, are called monadic. Predicates with more arguments are called dyadic, n-adic or poly-adic. Some languages are using monadic predicates while other languages can accept poly-adic predicates.</p>

<h4>Arguments</h4>

<p>The arguments are specific values, used to evaluate a predicate. Sometimes the arguments are called: predicate variables or parameters. In programming and mathematics a predicate is a function or an expression that can be evaluated to True or False depending on the arguments.</p>

<h4>Expressions</h4>

<p>Simplest predicates are the ones expressing properties of things. We use uppercase letters to express a predicate and lowercase letters to express arguments. Some examples of predicates:</p>

<ul>
  <li>A(x): x is tall</li>
  <li>B(x,y): x owes money to y</li>
  <li>C(x,y,z): x borrowed y from z</li>
</ul>

<h4>Domain</h4>

<p>A variable used in a predicate can be bound to a specific domain. When a variable is not bound, is called “free variable”. This is not an argument but it can influence the result of predicate. In logic papers you may encounter the name “universe of discourse” (UD) that is actually a domain or range of values from a particular data set.</p>

<h4>Data set</h4>

<p>A data set is a range of values. It can be numeric or can represent symbols or objects. A data set can be empty, or can have one or more elements. Some data sets can have an infinite number of elements. In a data-set the elements are unique. The elements in a data-set are usually ordered. A data set is represented as an enumeration of symbols separated by comma and enclosed in brackets, like:</p>

<ul>
    <li>A = {a, b, c}</li>
    <li>N = {1,2,3}</li>
</ul>

<h4>Relations</h4>

<p>Elements in a datasets can be associated using a relation. A relation between two arguments is called binary relation. The elements of a binary relation is the Cartesian product (x). A relation R is a predicate with (at least) two arguments:</p>

<pre class="output">
R = A x N = {(a,1), (a,2), (a,3), (b,1), (b,2), (b,3), (c,1), (c,2), (c,3)}
</pre>

<p>In logic, sometimes we use symbol “∼” to define relations: For example: x∼y means x is related to y. Also we can say that pair (x,y) belong to relation “∼”. Most of the time a relation is represented by a binary operator. For example we can use { =, &lt;, &gt; } to express the relation between numbers.</p>

<h4>Quantifiers</h4>

<p>In logic we use quantifiers to refer to a set of elements. The quantifier is a symbol that specify one or more elements we are referring to. So far I have not found programming languages that are using quantifiers. Usually a quantifier is implemented using one or more statements.</p>

<ul>
<li>∀ = all (universal quantifier)</li>
<li>∃ = exist (existential quantifier)</li>
</ul>

<div class="alert alert-info">Note: Qualifiers can be combined together to create meaningful predicate expressions. Most common we can use for all elements in domain there is or exist x that satisfy a relation R(x).</div>

<p>In programming, the exist "∃" can be implemented by searching for a particular element in a data set. If the element satisfy the relation the predicate is True, otherwise False.</p>

<h4>Belonging</h4>

<p>We can express if an element belong or does not belong to a particular domain or dataset. This is very helpful to establish meaningful logic expressions involving data sets.</p>

<ul>
<li>∈ means: “belong”</li>
<li>∉ means: “does not belong”</li>
</ul>

<p>Sometimes we factor out a qualifier to refer to more than one element. For example the expression: ∃(x,y,z) ∈ {0,1,2,3,4,5,6,7,8,9}, it means exist a pair of 3 single digit numbers.</p>

<div class="alert alert-info">Note: In programming we can refer to a range of numbers using square brackets. [x-y] or [x..y] or [x: y]. This convention is not the same in all languages. You must learn the specific syntax.</div>

<h4>Identity</h4>

<p>Identity is an equivalence relation. We have seen this symbol before, used for propositional logic: { “=” , “≡”}. This symbol is polymorphic. It can be used with any kind of elements not only propositions but also predicates or terms. It’s because identity relation is symmetric, transitive and reflexive.</p>

<h4>Properties</h4>
<p>Understanding relations requires knowing their properties. The following three properties are especially important in logic and mathematics:</p>

<ul>
    <li><b>Reflexive:</b> A relation '∼' on a set A is reflexive if every element is related to itself.
        <br><em>∀a ∈ A, a ∼ a</em>
    </li>
    <li><b>Symmetric:</b> A relation '∼' on a set A is symmetric if the order of the elements does not matter. If a is related to b, then b is related to a.
        <br><em>∀a, b ∈ A, (a ∼ b) → (b ∼ a)</em>
    </li>
    <li><b>Transitive:</b> A relation '∼' on a set A is transitive if a direct relationship between the first and second element and the second and third element implies a relationship between the first and third.
        <br><em>∀a, b, c ∈ A, ((a ∼ b) ∧ (b ∼ c)) → (a ∼ c)</em>
    </li>
</ul>

<p>An "equivalence relation" is a relation that is reflexive, symmetric, and transitive. The equality (=) operator is a common example of an equivalence relation.</p>

<h4>Order</h4>

<p>An set or range of elements is usually ordered. When a set is ordered you can apply special relations between consecutive elements.</p>

<p>For example we can study numbers and relation between numbers using predicate logic. A number can be greater, equal or less than other number. Also a number can be different or not equal to other number. In the next table we show you the most usual notation for comparison operators.</p>

<div class="table-wrapper">
<table class="table table-striped table-bordered table-dark">
<tbody>
<tr>
<th>Math</th>
<th>CS</th>
<th>Description</th>
<th>True = 1</th>
<th>False = 0</th>
</tr>
<tr>
<td>=</td>
<td>==</td>
<td>Equal</td>
<td>1 == 1&nbsp;</td>
<td>1 == 0</td>
</tr>
<tr>
<td>&ne;</td>
<td>!=</td>
<td>Not equal</td>
<td>1 != 0&nbsp;</td>
<td>1 != 1</td>
</tr>
<tr>
<td>&gt;</td>
<td>&gt;</td>
<td>Greater than</td>
<td>2 &gt; 1</td>
<td>5 &gt; 5 + 1</td>
</tr>
<tr>
<td>&lt;</td>
<td>&lt;</td>
<td>Less than</td>
<td>0 &lt; 1</td>
<td>1 &lt; 0</td>
</tr>
<tr>
<td>&ge;</td>
<td>&gt;=</td>
<td>Greater than or equal to</td>
<td>1 &gt;= 0</td>
<td>1 &gt;= 2</td>
</tr>
<tr>
<td>&le;</td>
<td>&lt;=</td>
<td>Less than or equal to</td>
<td>1 &lt;= 1</td>
<td>1 &lt;= 0</td>
</tr>
</tbody>
</table>
</div>

<h2><a id="list-sets">Lists &amp; Sets</a></h2>

<p>To understand the predicate logic better we need to grasp a sets and collections of things. A set is a group of things that are unique represented and not duplicated. All things in a set can be similar or can have characteristics in common. We call members of a set: <em>"elements"</em>. </p>

<div class="text-center">
  <img src="/images/set-example.svg" alt="Set Examples"
       width="600" class="img-fluid protect rounded shadow border" >
  <p>Examples of 2 Sets</p>
</div>

<p>Sometimes we need to make a collection of elements that can be duplicated. In this case we have a "list of elements" not a sets because some of the elements are not unique. We refer in computer science to a list or a set of element by using the term: <em>collection</em>.</p>

<p>Predicate logic study the elements of collections and the relations between them. For example an element can belong to a set or do not belong to a set. Two sets can contain the same elements or different elements. Then the sets are equal or not equal.</p>

<h4>Operations</h4>

<p>Operations between sets can produce new sets or logic results. Also it is possible to make operations between one set and one value to check if the value belong to a set. In next table we use Unicode symbols for operators between sets:</p>

<table class="table table-bordered table-striped table-dark" >
<thead>
<tr>
<th>symbol</th>
<th>example</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>&cap;</td>
<td>R = A &cap; B </td>
<td>Intersection between two sets  => new set</td>
</tr>
<tr>
<td>&cup;</td>
<td>R = A &cup; B</td>
<td>Union between two sets  => new set</td>
</tr>
<tr>
<td>&sub;</td>
<td>b = A &sub; B</td>
<td>Set is A included in superset B: => boolean</td>
</tr>
<tr>
<td>&sup;</td>
<td>b = A &sup; B</td>
<td>Set A contain subset B: => boolean</td>
</tr>
<tr>
<td>&Delta;</td>
<td>&Delta; = A - B</td>
<td>Set difference, => new set</td>
</tr>
<tr>
<td>&isin;</td>
<td>b = x &isin; A</td>
<td>Belong: check if element belong to collection => boolean</td>
</tr>
<tr>
<td>&equiv;</td>
<td>b = A &equiv; B</td>
<td>Equivalent: check if A has same elements as B => boolean</td>
</tr>
<tr>
<td>&forall;</td>
<td>&forall; x &isin; A </td>
<td>Any element: used in collection qualification => boolean</td>
</tr>
<tr>
<td>&exist;</td>
<td>&exist; x &isin; A</td>
<td>Exist: used in collection qualification => boolean</td>
</tr>
</table>

<h4>Intersection</h4>

<div class="alert alert-secondary">Intersection between two sets A, B will be a smaller set R that will contain all common elements of A and B. All other elements will not be included.</div>

<div class="text-center">
  <img src="/images/set-intersect.svg" alt="Intersection"
       width="380" class="img-fluid protect rounded shadow border" >
  <p>Set Intersection</p>
</div>

<h4>Union</h4>

<div class="alert alert-secondary">Union between two sets A, B will be a larger set R that contain all elements of A and all elements of B, but duplicate elements will be included only once.</div>

<div class="text-center">
  <img src="/images/set-union.svg" alt="Union"
       width="400" class="img-fluid protect rounded shadow border" >
  <p>Set Union</p>
</div>

<h4>Difference</h4>

<div class="alert alert-secondary">Difference between two sets A, B will be a set C that contain all elements of A but not elements that are common with B. There is a second difference D that we can make between B and A.</div>

<div class="text-center">
  <img src="/images/set-difference.svg" alt="Difference"
       width="600" class="img-fluid protect rounded shadow border" >
  <p>Set Difference</p>
</div>

<h4>Vector &amp; Matrix</h4>

<p>In mathematics there are 2 significant numeric collections: Vectors and Matrices. In Python we define a "List" that can have one or more dimensions and can hold a Vector or a Matrix. Some languages use term: "Array". Sometimes "Array" and "List" are different things with similar properties.</p>

<h3>Fuzzy Logic</h3>

<div class="alert alert-secondary shadow-sm">Fuzzy logic is an attempt to incorporate nature's inherent fuzziness into technology. This logic works not only with values 1=True and 0=False but we some values in between. Not everything is black or white but there is a gray area. This may be related to probabilistic values that are values between 0 and 1. Fuzzy Logic is used in neural networks and machine learning.</div>

<p>The theory of Quantum Computing is using a similar concept called <em>"Quantum Logic"</em>. This is based on quantum bits (qbits). The difference is that number of states between {0,1} in quantum computing is limited while in fuzzy logic the number of states between {0,1} are infinite.</p>

<h2><a id="machines">State Machines</a></h2>

<div class="alert alert-secondary shadow-sm">A "state machine", is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. We call this also a "Finite State Machine" FSM.</div>

<h3>Moore machines</h3>

<p>Moore machine was invented by Edward Moore in 1956 and is called Moore machine. Moore machines consist of states and transitions. States are able to produce outputs, and the output is determined solely by the current state, not by any input.</p>

<h3>Mealy machines</h3>

<p>Mealy machines were invented by George H. Mealy in 1955. In comparison with Moore machines, Mealy machines produce outputs only on transitions and not in states. This often results in state diagrams with fewer states because more logic can be put on transitions.</p>

<h3>Harel state charts</h3>

<p>A state chart is a visual formalism for complex systems. Basically Harel state charts are Mealy/Moore state machines extended by further concepts that allow us to model complex systems in a practical way.</p>

<p>David Harel did his PhD in 1978 at the Massachusetts Institute of Technology in Cambridge. He then became a Professor for Computer Science at the Weizmann Institute in Jerusalem in 1980.</p>

<blockquote class="alert alert-warning"><b>David Harel: &nbsp;</b>A complex system cannot be beneficially described in this naive fashion, because of the unmanageable, exponentially growing multitude of states, all of which have to be arranged in a flat non stratified fashion, resulting in an unstructured, unrealistic, and chaotic state diagram.</blockquote>

<h3>UML state-chart</h3>

<p>UML stands for "Unified Modeling Language". UML state machines have the characteristics of both Mealy machines and Moore machines.UML state machine is an object-based variant of Harel state chart.</p>

<h3>Usability</h3>

<p>State machines are useful to analyze and theorize the computation using abstract notations. In practice there are efforts to create various code generators to translate the state charts into source code.</p>

<h3>Representation</h3>

<p>State machines can be represented in form of tables and diagrams. States are represented in diagrams by round circles, or shapes and transitions between states by arc of circles with arrow at end. A state machine diagram is usually oriented from top down or from left to right. The entry point is usually represented by a black dot. Some states are marked as "accepting" states with double line circle.</p>

<div class="text-center">
  <img src="/images/state-machine.svg" alt="state-machine"
       width="300" class="img-fluid protect rounded shadow border" >
  <p>State Machine</p>
</div>

<h2><a id="turing-machine">Turing Machine</a></h2>

<div class="alert alert-secondary shadow-sm">The Turing Machine is a theoretical model of computation invented by Alan Turing in 1936, predating modern computers. It was not a physical machine for code-breaking, but rather an abstract concept that defines the limits of what is computable. This model was fundamental to the development of computer science.</div>

<p>Separately, during World War II, Alan Turing designed an electro-mechanical machine called the Bombe, which was instrumental in breaking the German Enigma code. However, the Bombe and the theoretical Turing Machine are not the same thing.</p>

<p>Today, we use the term "Turing Complete" to classify a programming language or system that has a computational power equivalent to a universal Turing machine. Theoretically, such a system can solve any problem that a computer can solve, given enough time and memory. A Turing machine can be represented as a finite state machine, but a conceptual diagram is often easier to grasp:</p>


<div class="text-center">
  <img src="/images/turing-machine.svg" alt="Turing Machine"
       width="640" class="img-fluid protect rounded shadow border" >
  <p>Turing Machine</p>
</div>


<h2><a id="inteligence">Artificial Intelligence</a></h2>

<div class="alert alert-secondary shadow-sm">Artificial intelligence is often used to describe machines (or computers) that mimic cognitive functions usually associated with the human mind, such as <em>learning</em> and <em>reasoning.</em></div>

<h3>Machine Learning</h3>

<p>While true <em>artificial intelligence</em> has not yet been achieved, we have created <em>machine learning</em>, a field of AI that uses statistical techniques to enable computer systems to "learn" from data. It is built on the idea that by analyzing vast amounts of data, a system can identify trends and patterns, which can be used to make predictions or recognize new patterns, thereby simulating a form of intelligence.</p>

<h4>Example:</h4>

<div class="text-center">
  <img src="/images/statistic-trend.svg" alt="Statistic Trend"
       width="600" class="img-fluid protect rounded shadow border" >
  <p>Statistic Chart<br>Linear Trend</p>
</div>

<h3>Neural Network</h3>

<p>Neural networks are a key component of machine learning, in which a computer learns to perform a task by analyzing training examples. Typically, these examples have been hand-labeled in advance.</p>

<p>Most modern neural networks are organized into layers of nodes and are "feed-forward," meaning data moves through them in only one direction. An individual node might be connected to several nodes in the layer from which it receives data and several nodes in the layer to which it sends data.</p>

<div class="text-center">
  <img src="/images/neural-network.svg" alt="Neural Network"
       width="520" class="img-fluid protect rounded shadow border" >
  <p>Neural Network <br> Conceptual Representation</p>
</div>

<p>The concept of neural networks was first proposed in 1944 by Warren McCullough and Walter Pitts, two University of Chicago researchers who later moved to MIT in 1952 as founding members of what is sometimes called the first cognitive science department.</p>

<h3>DEI in AI</h3>
<p>DEI in AI stands for diversity, equity, and inclusion. It is the practice of ensuring that AI systems are fair and inclusive, and that they do not discriminate against people based on their race, gender, religion, or other protected characteristics.</p>
<p>DEI in AI is important because AI systems are increasingly being used to make decisions that affect people's lives, such as whether they get a job or a loan. If these systems are biased, they can perpetuate discrimination and inequality.</p>
<p>There are a number of ways to promote DEI in AI, such as:</p>
<ul>
  <li>Using diverse data sets to train AI systems.</li>
  <li>Developing AI systems that are fair and unbiased.</li>
  <li>Training AI developers on DEI principles.</li>
  <li>Monitoring AI systems for bias and discrimination.</li>
  <li>Taking steps to mitigate bias and discrimination in AI systems.</li>
</ul>
<p>DEI in AI is a complex and challenging issue, but it is important to address it in order to ensure that AI systems are fair and inclusive.</p>

<h3>What is LLM?</h3>

<p>LLM stands for **Large Language Model**. It is a type of artificial intelligence (AI) that is trained on a massive amount of text data. This data can include books, articles, code, and other forms of written language. LLMs are able to learn the patterns and relationships between words and phrases in this data, which allows them to generate new text that is similar to the text they were trained on.</p>

<p>LLMs are used in a variety of applications, including:</p>

<ul>
  <li><strong>Machine translation:</strong> LLMs can be used to translate text from one language to another. For example, Google Translate uses an LLM to translate text between over 100 languages.</li>
  <li><strong>Text summarization:</strong> LLMs can be used to summarize long pieces of text into shorter summaries. This can be useful for quickly getting the main points of a document or article.</li>
  <li><strong>Chatbots:</strong> LLMs can be used to create chatbots that can have natural conversations with humans. This can be used for customer service applications, or for providing information or assistance to users.</li>
  <li><strong>Creative writing:</strong> LLMs can be used to generate creative text formats, like poems, code, scripts, musical pieces, email, letters, etc. This can be used for entertainment purposes, or for generating new ideas.</li>
</ul>

<p>LLMs are still under development, but they have already learned to perform many kinds of tasks. As LLMs continue to develop, they are likely to become even more powerful and versatile.</p>

<p>Here are some examples of LLMs:</p>

<ul>
  <li><strong>GPT-3:</strong> GPT-3 is an LLM developed by OpenAI. It has 175 billion parameters and is one of the most powerful LLMs in the world. GPT-3 can be used for a variety of tasks, including machine translation, text summarization, and creative writing.</li>
  <li><strong>LaMDA:</strong> LaMDA is an LLM developed by Google AI. It is similar to GPT-3 in terms of its capabilities, but it has been specifically designed to be more factual and less likely to generate offensive or harmful content.</li>
  <li><strong>Megatron-Turing NLG:</strong> Megatron-Turing NLG is an LLM developed by Google AI and NVIDIA. It is the largest LLM in the world, with 530 billion parameters. Megatron-Turing NLG is still under development, but it has already shown promising results in machine translation and text summarization.</li>
</ul>

<p>LLMs are a powerful new tool that has the potential to revolutionize the way we interact with computers. As LLMs continue to develop, they are likely to become even more important in our lives.</p>

<h3>Generative AI</h3>

<p>
  Generative AI is a branch of artificial intelligence (AI) that focuses on creating new content, such as text, images, audio, and code. It is able to learn the patterns and structures of existing data and then use this knowledge to generate new data that is similar in style or form. This makes it a powerful tool for a variety of applications, including art, design, and product development.</p>
  
<h3>Disclaimer</h3>

<p>This website was improved using AI. You can use AI for free using Google's web application. All you need is a Google account. This service is in public beta. While AI can assist with programming, its suggestions should be carefully reviewed for correctness and security.</p>

<p>Google AI: <a href="https://gemini.google.com" target="_blank" rel="nofollow noopener">Gemini</a></p>

<div class="alert alert-warning"><b>Warning: </b>AI can make mistakes. It may generate multiple responses, and you can select and vote on which is better. AI learns from user feedback. If you use AI-generated content, you must verify and validate the response.</div>

<p><b>Read next:</b>
<a href="/engineering/algebra/">Numeric Algebra</a></p>
</main>
</div>
</div>
<hr>
<!-- Footer -->
<footer class="footer copyright">
  <p class="x-small text-secondary mb-0">&copy; 2026 Sage-Code Laboratory</p>
</footer>
</div>
<!-- sidebar button -->
<button id="open-sidebar" class="btn btn-primary d-lg-none shadow-lg">
  <span style="font-size: 24px;">☰</span>
</button>
<!-- my scripts -->
<script src="/sage.js" defer></script>
<script src="/sidebar.js" defer></script>
<script src="/progress.js" defer></script>
</body>
</html>