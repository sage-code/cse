<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code Eve data processing. Feature requirement document">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="SageCode, EVE, data processing, collection builder, union, append, enqueue, dequeue, hashmap">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Eve Processing</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Eve code highlighter -->
  <script src="js/eve.js"></script>
  <!-- Sage-Code custom CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="eve_render();">

<div class="container">

<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.pro"><img src="../images/sage-logo.svg" 
           alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</header><hr>

<h1>Eve Processing</h1>

<div class="alert alert-secondary shadow-sm">Data processing is an important use case of Eve. A process can modify states, initialize variables, add/modify or remove data in collections, make computations and decision statements to resolve problems. Next we analyse some use cases:</div>

<h4>Page bookmarks:</h4>
<hr>
<ul>
  <li><a href="#main-process">Main process</a></li>
  <li><a href="#parallel">Parallel processes</a></li>
  <li><a href="#exceptions">Exception handling</a></li>
</ul>
<hr>

<a><a id="main-process"></a>Process</h2>

<p>A process can do one or more jobs. Each job is a try block. Jobs are sequential. Any job can pass or fail. User can force a job to pass or fail. Also user can decide if process can continue with next job. When an exception is raised a process is interrupted.</p>

<p>In case of exception, the workflow jumps into recover region. If none of the cases is handling the error, the finalization region is executed and the process terminates. Errors can propagate to main process if they are not properly handled.</p>


<p>Jobs can be dependent. If first job fail, maybe does not make any sense to continue with next job. In recover region, user can detect what job is the current job that failed. So user can do different error handling for different job or group of jobs.</p>


<div align="center">
  <img src="img/eve-try.svg" alt="try blocks"
  width="500" class="img-fluid protect rounded shadow border" >
  <p>job ... try</p>
</div>

<h4>Pattern:</h4>

<p>Next design pattern show how to create several jobs in a process. Having a process with jobs will enhance your ability to crate robust code that can handle errors and prevent catastrophic defects.</p>

<pre><code class="language-eve">
# define process with label
process | initialize:
  ** local declarations
  ....
  ** preconditions
  exit if condition;
job (c1,"description") try
  ...
  raise "error" if condition; -- recoverable
  ...
  exit if condition; -- execute finalization
  ...
  pass if condition; -- continue next job
  ...
  fail if condition; -- continue next job
  ...
job (c2,"description") try
  ...
job (c3,"description") try
  ...
recover
  ** check if a resume is required
  resume if condition1; 
  resume if condition2;
  ...
  ** exception handlers
  case error1 then
    ** exception handler
    ...
  case error2 then   
    ...
    retry | panic;
  else
    ...
    retry } panic; 
finalize
    ** close resources
    ...
    ** report the errors
    ...
return;
</code></pre>

<h3>Process Keywords</h3>

<p>The process is created and controlled by many keywords. Mastering these keywords is important to use the process effective. We have chosen keyword careful to be easy to memorize.</p>

<table class="table table-sm table-bordered">
<tr><th>job</th><td>create one step in the process</td></tr>
<tr><th>try</th><td>begin job executable block</td></tr>
<tr><th>catch</th><td>handle an error in current job</td></tr>
<tr><th>pass</th><td>record success, and skip to next job</td></tr>
<tr><th>fail</th><td>record failure, and execute next job</td></tr>
<tr><th>retry</th><td>redo the task that raise a recoverable error</td></tr>
<tr><th>exit</th><td>ignore next jobs and execute the finalization</td></tr>
<tr><th>resume</th><td>return in the process and execute next job</td></tr>
<tr><th>raise</th><td>create a recoverable error, jump to recovery</td></tr>
<tr><th>panic</th><td>jump to finalize and stop the application</td></tr>
</table>

<h4>Notes</h4>

<ul>
<li>Any driver or aspect, must implement one process;</li>
<li>A process create a local scope, but also has access to a global context;</li>
<li>Before first job there is a region for preparation/preconditions</li>
<li>Preconditions can stop the process and do not trigger finalization region</li>
<li>You should not call exit from recover, the exit is automatic</li>
<li>Jobs can't be nested, they are all on same level with process</li>
<li>Process local variables are allocated dynamic when process starts;</li>
<li>All tasks of a single process are execute sequential from top down;</li>
<li>When the last task is finished the local variables are removed;</li>
<li>You can create local lambda expressions and objects;</li>
<li>You can't define classes, in processes but you can initialize objects;</li>
<li>Alternative to jobs, a process can call aspects using the "run" command;</li>
</ul>

<p><b>Process execution</b>&nbsp; A processis executed using "run" command with aspect name and list of arguments, from a driver. For one single argument, or no argument the parentheses are not required in the aspect call. For a list of arguments you use parenthesis;</p>

<pre><code class="language-eve">#these are all valid process calls
run aspect_name; -- call process without arguments
run aspect_name argument_value;      -- call with single argument
run aspect_name (value, value, ...); -- call with a list of arguments
run aspect_name (param:value,...);   -- call with a argument by name
run aspect_name (value, value, param:value); -- mix position with names
run aspect_name (value, *list_args);         -- use spreading operator
run aspect_name (param:value, *map_args);    -- mix names with hashmap
</code></pre>

<h3>Process interruption</h3>

<p>A process normal ends with keyword return. When aspect process is terminated, program execution will continue with the next statement in the main process. Interruption keywords (exit, over, panic) can be used to interrupt a process. The <em>exit</em> or <em>raise</em> trigger the finalization region while "over" and "panic" skip the finalization region.</p>


<h4>Example:</h4> 

<pre><code class="language-eve">
# simple aspect with one parameter
aspect print_this(p:String):
process:
  print p;
return;
</code></pre>

<pre><code class="language-eve"># driver with parameters
driver process_call(*args ()String):
process:
  ** number of arguments received:
  cycle:
    new arg: String;
  for arg in args loop;
    apply print_this(arg);
  repeat;
return;
</code></pre>

<h3>Aspect Execution:</h3>

<p>One aspect is executed from a driver. You can not execute an aspect from itself. Recursive aspects are not supported. The compiler will detect a recursive aspect and will fail at runtime.</p>

<h4>Synchronously</h4>

<p>Aspects can be executed in serial mode one after another. Let's consider we have 3 aspects: {one, two, three}. Main process can execute each aspect using keyword: "run" and can block the main process uwing wait. This will interrupt the driver process and will execute aspect process one by one:</p>

<pre><code class="language-eve">
driver test_apply:

# synchronous call
process:
  ** apply each aspect
  run [folder/]aspect_one(arguments);   wait;
  run [folder/]aspect_two(arguments);   wait;
  run [folder/]aspect_three(arguments); wait;
  ...
return;
</code></pre>

<p><b>Note: </b>You do not have to import an aspect into a driver but you must specify the relative path of the aspect. If the aspect is in a subfolder, you must include relative folder name. If the aspect is in the same location as the driver, you do not need a folder name.</p>


<h2><a id="parallel"></a>Parallel processes</h2>

<p>You can create parallel processes using multiple aspects. Processes ca be executed on multi-core processors one for each core. Not all processes have same duration. You can wait in the driver for a process to finish. </p>

<!-- a regular diagram -->
<div class="text-center">
  <img src="../images/parallel_system.svg" alt="Parallel system"
    width="540" class="img-fluid protect rounded shadow border" >
  <p>Parallel System</p>
</div>

<p>Aspects can be executed asynchronously using keywords "run" and "wait all". This is not blocking the main process and you can start multiple aspects in parallel. Each aspect will start it's own process in this case.</p>

<pre><code class="language-eve">
# asynchronous call demo
driver async_demo:
process:
  ** enqueue aspects to be resolved
  run [folder/]aspect_one(arguments);
  run [folder/]aspect_two(arguments);
  run [folder/]aspect_three(arguments);

  ** wait for all aspects to finish
  wait all;
return;
</code></pre>

<p>One driver can start same aspect multiple times with different parameters and compute different data sets. Next example show how to execute one aspect using a loop. After the aspect start several times, the main process must wait for all to finish.</p>

<pre><code class="language-eve">
## create parallel processes
driver async_loop:
process:
  ** enqueue same aspect 4 times
  cycle
    new i: Integer;
  for i in (1..4) loop
    run demo(i);
  repeat;
  wait all;
return;
</code></pre>

<hr>

<h2><a id="exceptions"></a>Exceptions</h2>

<p>An exception is an object that has methods. The EVE system defines several system variables and system objects used to handle exceptions. In Eve, all exceptions are considered errors. We can monitor jobs using a log and record exceptions in this log. Exceptions from one aspect process can propagate to the main process.</p> 

<p>The "error" is a variable of type Exception.Error that is created when an exception is raised. The system variable $error contains several elements that are errors. These are filled in by the Eve program when an exception is raised.</p> 

<p>Error handling in Eve is done at the process level. A process can be interrupted by a system exception or it can create user-defined exceptions. We use special keywords to signal an exception from inside a job.</p>

<h4>Pseudocode</h4>

<p>The Exception module is not yet created. We have the intention to use Eve to create this module. Next is a prototype that explain the structure of future Exception module. It define class .Error that is public and several metods.</p> 

<pre><code class="language-eve">** system exception type
module Exception:

class .Error: {
  code: Integer, 
  message: String, 
  module: String, 
  line:Integer
} &lt;: Object;

class .Error = {code: Integer, message: String} => (@self :Error):
  let self.code := code;
  let self.message := message;
return;

class Call = {line:String, method:String} => (@self:Call):
  let self.line   := line;
  let self.method := method;
return;

** system variables 
global
  set $error: Error;   -- last error

  ** system objects;
  set $stack: ()Call;  -- list of calls
  set $trace: ()Error; -- list of errors

** methods for Exceptions
method (@self:Error) .raise(...);
method (@self:Error) .expect(...);
method (@self:Error) .pass(...);
method (@self:Error) .fail(...);
  
return;
</code></pre>

<h3><a id="run-time-errors"></a>Runtime Errors</h3>

<p>Runtime errors can be system exceptions or user defined exceptions. System exceptions are predefined in the Exception package. Every system module can define system errors. User errors can be defined in project library.</p>

<p>Error instances are created during the program execution when program can not continue. An error can be raised by application modules, aspects or drivers or by the system modules.</p>

<h3>Raising exception</h3>

<p>There are two alternative statements to create user defined exceptions: "raise", "expect". These methods are static methods defined in  Exception module. You can raise exception from processes, coroutines, methods and functions.</p>

<pre><code class="language-eve">
** system exception
raise $ExceptionType("message");

** user-defined exception
raise (code,"message") if condition;
</code></pre>

<h3>Using expect</h3>

<p>The "expect" statement can check a condition and raise an error if condition is false. Error message is default: "Unexpected error in line: N". Optional you can define a custom message.</p>

<h4>Pattern:</h4>

<pre><code class="language-eve">** runtime expectations
expect condition1;
expect condition2 else "user defined message";
</code></pre>

<h4>Nots:</h4>
<ul>
<li>can be used as pre-condition</li>
<li>can be used as post-condition</li>
<li>unexpected error has code = 0</li>
</ul>

<h3>Recover from exception</h3>

<p>The <b>recover</b> region define an "exception handling region" for a processes. Coroutines, methods and functions can't handle exceptions. Recover region is a optional. If this region do not exist in a process, all exceptions propagate into the main process. If the main process to not have a recover region, exception can stop/crash the application.</p>

<p>In recover region developer can decide to abort the program, print a message, resume the execution or wait and tray again. Maybe a second time will work. Aspect processes should handle as much as possible to keep the concerns separated. Main process will handle the general case just in case.</p>


<h4>Example:</h4>
<pre><code class="language-eve">#using recover
driver recover_demo:
  set a = 0.00;
process
  let a := 1/0;
recover
  print $error.message;
return;
</code></pre>

<h4>Output:</h4>

<pre class="output">error: numeric division by zero.</pre>


<!-- work in progress-->

<hr>
<p><b>Read next:</b>
<a href="algorithms.html">Eve Algorithms</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>