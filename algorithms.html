<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Introduction of software common algorithms. Overview and references.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="software, engineering, algorithms, overview">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Website title -->
  <title>Programming Algorithms</title>  

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="images/favicon.ico">  
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="prism.css">
  <script src=""></script>
  <!-- custom css -->
  <link rel="stylesheet" href="sage.css">
  </head>
<body>

<div class="container">
        
<!-- header -->
<header class="row">
    <div class="col">
        <a href="https://sagecode.pro"><img src="images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"></a>
    </div>  
    <div class="col  bottom-right">
        <a href="engineering.html" rel="nofollow">engineering</a>&lt;--
    </div>
</header><hr>

<h2>Programming Algorithms</h2>

<div class="alert alert-secondary shadow-sm">
An algorithm is a set of instructions or rules that are designed to solve a specific problem. It is a step-by-step procedure that takes a defined input, performs some operations on it, and produces a desired output. 
</div>


<p>Algorithms are an essential part of computer science and are used in a wide range of applications, such as data analysis, sorting, searching, cryptography, and artificial intelligence.</p>

<h2>Algorithm Properties</h2>

<p>Any algorithm must have an input which can be defined or generated automaticly. Also an algorithm must produce some output, which can be defined, null or undefined.</p>

<p>Algorithms must be well defined, comprehensible, finite, correct and efficient. We study algorithms in Computer Science. When you study algorithms you must pay atention to quality aspects, usability and performance.</p>

<h2>Algorithm Quality</h2>

<p>Quality refers to the degree to which a product or service meets the needs and expectations of the customer. For algorithms, quality refers to how well the algorithm performs in terms of efficiency, accuracy, maintainability, and robustness.</p>

<table class="table table-bordered table-striped table-dark" >
  <thead class="thead-light">
    <tr>
      <th>Attribute</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Efficiency</td>
      <td>Measures the speed and resource usage of an algorithm, such as time complexity and space complexity.</td>
    </tr>
    <tr>
      <td>Accuracy</td>
      <td>Refers to how precise or correct the algorithm's output is, often measured with metrics such as error rate and deviation.</td>
    </tr>
    <tr>
      <td>Maintainability</td>
      <td>Refers to how easy it is to modify or adapt the algorithm, such as having clean and well-documented code.</td>
    </tr>
    <tr>
      <td>Robustness</td>
      <td>Refers to how well the algorithm handles unexpected or erroneous inputs, such as invalid or missing data.</td>
    </tr>
    <tr>
      <td>Scalability</td>
      <td>Refers to how well the algorithm performs as the input size grows or the system load increases, such as having constant or logarithmic complexity.</td>
    </tr>
    <tr>
      <td>Security</td>
      <td>Refers to how well the algorithm ensures the confidentiality, integrity, and availability of sensitive data, such as encryption and access control.</td>
    </tr>
    <tr>
      <td>Usability</td>
      <td>Refers to how user-friendly and intuitive the algorithm is for non-technical users, such as having clear instructions and feedback.</td>
    </tr>
    <tr>
      <td>Portability</td>
      <td>Refers to how easily the algorithm can be used in different environments or platforms, such as being compatible with multiple programming languages and operating systems.</td>
    </tr>
  </tbody>
</table>

<p>By focusing on these quality attributes, algorithm designers and developers can ensure that the final product meets the needs and expectations of the customer and performs well in real-world scenarios</p>


<h2>Well known algorithms</h2>

<p>
When choosing an algorithm, there are several factors that should be considered, including the problem constraints, the required speed and accuracy, the available resources, and the complexity of the problem. One common approach is to start with a simple algorithm that solves the problem but may not be very efficient, and then optimize it as needed to improve its performance.</p> 

<p>Another approach is to choose a well-established algorithm that is known to work well for similar problems, and then modify it as needed to fit the specific problem requirements. It's also important to consider the trade-offs between different algorithms, such as performance vs. accuracy, and to choose the algorithm that best meets the specific problem requirements.
</p>

<h3>Sorting Algorithms</h3>
<p>Sorting algorithms are used to arrange data in a specific order. There are several sorting algorithms, such as:</p>
<ul>
  <li>Bubble sort</li>
  <li>Insertion sort</li>
  <li>Merge sort</li>
  <li>Quick sort</li>
  <li>Selection sort</li>
</ul>

<h3>Searching Algorithms</h3>
<p>Searching algorithms are used to find specific data in a collection. There are several searching algorithms, such as:</p>
<ul>
  <li>Binary search</li>
  <li>Depth-first search</li>
  <li>Breadth-first search</li>
</ul>

<h3>Graph Algorithms</h3>
<p>Graph algorithms are used to traverse and manipulate graphs. There are several graph algorithms, such as:</p>
<ul>
  <li>Depth-first search</li>
  <li>Breadth-first search</li>
  <li>Dijkstra's algorithm</li>
  <li>Prim's algorithm</li>
  <li>Kruskal's algorithm</li>
</ul>

<h3>Dynamic Programming</h3>
<p>Dynamic programming algorithms are used to solve problems by breaking them down into smaller sub-problems. There are several dynamic programming algorithms, such as:</p>
<ul>
  <li>Fibonacci series</li>
  <li>Knapsack problem</li>
  <li>Longest common subsequence</li>
  <li>Matrix chain multiplication</li>
</ul>

<h3>Greedy Algorithms</h3>
<p>Greedy algorithms are used to solve problems by making the locally optimal choice at each stage. There are several greedy algorithms, such as:</p>
<ul>
  <li>Activity selection problem</li>
  <li>Huffman encoding</li>
  <li>Minimum spanning tree problem</li>
</ul>

<h3>Divide and Conquer</h3>
<p>Divide and conquer algorithms are used to solve problems by dividing them into smaller sub-problems, solving each sub-problem recursively, and then combining the solutions. There are several divide and conquer algorithms, such as:</p>
<ul>
  <li>Binary search</li>
  <li>Merge sort</li>
  <li>Quick sort</li>
  <li>Strassen's algorithm for matrix multiplication</li>
</ul>


<h2>Algorithm Efficiency</h2>

<p>Efficiency is a key attribute of algorithms, as it measures how fast and how much resources an algorithm consumes to solve a problem. There are two main aspects of algorithm efficiency:</p>

<ul>
  <li><strong>Time Complexity:</strong> Measures how many operations an algorithm takes to complete, as a function of the input size (n). Common notations for time complexity include O(1), O(log n), O(n), O(n log n), O(nÂ²), and O(2^n).</li>
  <li><strong>Space Complexity:</strong> Measures how much memory an algorithm uses to store data and intermediate results, as a function of the input size (n). Common notations for space complexity include O(1), O(log n), O(n), O(n log n), O(nÂ²), and O(2^n).</li>
</ul>

<p>Efficient algorithms aim to have low time and space complexities, as they can handle larger input sizes and run faster with limited resources. However, improving one aspect of efficiency may come at the cost of the other. Therefore, finding the optimal balance between time and space complexity can be a trade-off that depends on the specific problem and the available resources.</p>

<p>For example, a sorting algorithm with O(n log n) time complexity and O(1) space complexity may be preferred over another sorting algorithm with O(nÂ²) time complexity and O(n) space complexity for small input sizes, but the latter may be preferred for large input sizes where memory is not a constraint.</p>


<table class="table table-bordered table-hover">
<thead>
<tr>
    <th>Algorithm</th>
    <th>Time Complexity</th>
    <th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr>
    <td>Bubble Sort</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Selection Sort</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Merge Sort</td>
    <td>O(nlogn)</td>
    <td>O(n)</td>
</tr>
<tr>
    <td>Quick Sort</td>
    <td>O(nlogn)</td>
    <td>O(logn) - O(n)</td>
</tr>
<tr>
    <td>Binary Search</td>
    <td>O(logn)</td>
    <td>O(1)</td>
</tr>
<tr>
    <td>Breadth-First Search</td>
    <td>O(V+E)</td>
    <td>O(V)</td>
</tr>
<tr>
    <td>Depth-First Search</td>
    <td>O(V+E)</td>
    <td>O(V)</td>
</tr>
</tbody>
</table>


<h2>Artificial intelligence</h2>

<p>Artificial intelligence (AI) heavily relies on algorithms to perform tasks such as decision-making, pattern recognition, natural language processing, and computer vision. Some of the most popular AI algorithms include:</p>

<ul>
  <li>Artificial intelligence (AI) heavily relies on different algorithms to perform a variety of tasks such as decision-making, pattern recognition, natural language processing, and computer vision.</li>
  <li>Some of the most popular AI algorithms include Neural Networks, Reinforcement Learning, Genetic Algorithms, and Decision Trees.</li>
  <li>The future of algorithms development is likely to involve advances in areas such as quantum computing, deep learning, and natural language processing.</li>
  <li>We can expect more complex algorithms and new paradigms such as quantum computing to tackle even more challenging computational problems and achieve breakthroughs in fields like drug discovery, climate modeling, and space exploration.</li>
  <li>The role of algorithms in our daily lives will continue to grow, influencing everything from social media feeds to healthcare diagnostics.</li>
</ul>

<h2>Future research</h2>

<p>In the future, we can expect advances in areas such as quantum computing, deep learning, and natural language processing. With more complex algorithms and new paradigms, we may be able to tackle even more challenging computational problems and achieve breakthroughs in fields like drug discovery, climate modeling, and space exploration.</p>


<p>As AI continues to become more widespread, the role of algorithms in our daily lives will continue to grow, influencing everything from social media feeds to healthcare diagnostics.</p>


<hr>
<p><b>Read next:</b>
<a href="systems.html">System Design</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>