<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Sage-Code Bee program structure.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, bee, bee-lang, language, syntax">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Website title -->
  <title>Bee Structure</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="/images/favicon.ico">
  <!-- Bee Highlighter -->
  <script src="js/bee.js"></script>
  <!-- Sage-Code CSS -->
  <link rel="stylesheet" href="/bee/../sage.css">
  </head>
<body onload="bee_render()">
<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.pro"><img src="/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="/bee/index.html#lang-index" rel="nofollow" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>

<h1>Code Structure</h1>

<div class="alert alert-secondary shadow-sm">
Bee has a modular architecture. A source file represents a module. A project can have many modules and can contain other files like configuration files, images and data files. Let's focus first on Bee modules. Each module has extension *.bee and has a distinct role depending on its declaration and location.
</div>

<h4>Page bookmarks:</h4>
<p>Next you can learn general concepts about Bee applications:</p>
<ul>
<li><a href="#project">Project</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#external-code">External Code</a></li>
<li><a href="#name-space">Name space</a></li>
<li><a href="#execution">Execution</a></li>
</ul>

<h2><a id="project" class="anchor" href="#project"></a>Projects</h2>
<p>A Bee project is a folder with a specific structure. A project contains one or more applications that can run independent of each other on same computer or a group of computers. For example applications can be designed to collaborate with each other into n-tire architecture or can be a group of OS commands for image manipulation.</p>

<p><b>project tree</b></p>
<p>Next project tree contains two applications: client/server and show folders where you should put your code (src+lib) and documentation (doc). This is a recommendation but not a hard rule. You can organize your project better if you are experienced developer.</p>
<pre><code class="language-bee">$pro_home
  |-- bin
  |   |-- client.exe
  |   |-- server.exe
  |
  |-- src
  |   |-- module1.bee
  |   |-- module2.bee
  |
  |-- lib
  |   |-- library1.bee
  |   |-- library2.bee
  |
  |-- doc
  |   |-- readme.md
  |   |-- index.html
  |
  |-- client.bee
  |-- server.bee
</code></pre>

<h3>System Variables</h3>

<p>System variables are using "$" prefix. There are several predefined system variables available in Bee. These can be used to locate project files or connect to databases. You can define new system variables at the beginning of main module or in configuration files.</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Variable</th>
<th>Environment</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$bee_home</td>
<td>BEE_HOME</td>
<td>Bee home folder</td>
</tr>
<tr>
<td>$bee_lib</td>
<td>BEE_LIB</td>
<td>Bee library home</td>
</tr>
<tr>
<td>$bee_path</td>
<td>BEE_PATH</td>
<td>Bee library path</td>
</tr>
<tr>
<td>$pro_home</td>
<td>N/A</td>
<td>Project home folder</td>
</tr>
<tr>
<td>$pro_lib</td>
<td>N/A</td>
<td>Project library folder</td>
</tr>
<tr>
<td>$pro_mod</td>
<td>N/A</td>
<td>Project modules folder</td>
</tr>
<tr>
<td>$pro_log</td>
<td>N/A</td>
<td>Log output folder</td>
</tr>
</tbody>
</table>

<h3><a id="compiler-directives"></a>Compiler directives</h3>

<p>Compiler directives are system variables that control the compilation process. You can setup these options in compiler configuration file or in source file. You can not change these options after compilation. They are available for introspection.</p>

<p>System environment variables are using the same prefix "$". So there is a conflict. To avoid this conflict, you should use capital letters for environment variables. Bee is loading only environment variables specific to Bee.</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Constant</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$max_precision</td>
<td>0.00001</td>
<td>Control numeric precision</td>
</tr>
<tr>
<td>$max_recursion</td>
<td>10000</td>
<td>Control how deep a recursion before give up</td>
</tr>
<tr>
<td>$max_iteration</td>
<td>0</td>
<td>Control how many iterations before give up</td>
</tr>
<tr>
<td>$loop_timeout</td>
<td>60</td>
<td>Control time in seconds before a loop is forced to give up</td>
</tr>
<tr>
<td>$log_debug</td>
<td>"Off"</td>
<td>Control if debug information is included</td>
</tr>
<tr>
<td>$log_echo</td>
<td>"Off"</td>
<td>Control if statement is printed to console in case of error</td>
</tr>
<tr>
<td>$log_trace</td>
<td>"Off"</td>
<td>Control if @trace variable is getting populated with information</td>
</tr>
<tr>
<td>$date_format</td>
<td>"DMY" / "MDY"</td>
<td>Control date format: DD/MM/YYYY or MM/DD/YYYY</td>
</tr>
<tr>
<td>$time_format</td>
<td>"T24" / "T12"</td>
<td>Control time format: HH:MM:SS,MS am/pm or HH:MM:SS,MS</td>
</tr>
<tr>
<td>$platform</td>
<td>"Windows"</td>
<td>Alternative: "Linux", "Mac" is the target platform</td>
</tr>
</tbody>
</table>

<h4>Notes:</h4>
<ul>
<li>You can set compiler parameters in the main module but not in <em>secondary modules</em></li>
<li>Precision is controlling only rational numbers.;</li>
</ul>

<h3><a id="global-variables"></a>Global Variables</h3>
<p>Global variables are defined usually at the beginning of a module outside of any rule. </p>

<h4>introspection:</h4>

<p>Following system variables are available for debugging:</p>
<table class="table table-bordered table-sm table-striped">
<tr><td width="15%">$timer   </td>
<td>duration information about last statement     </td></tr>
<tr><td>$stack   </td>
<td>debug information about current call stack    </td></tr>
<tr><td>$trace   </td>
<td>reporting information about statements        </td></tr>
<tr><td>$query   </td>
<td>last query statement                          </td></tr>
<tr><td>$error   </td>
<td>last error object                             </td></tr>
<tr><td>$threads </td>
<td>number of active threads                      </td></tr>
<tr><td>$trial </td>
<td>trial object, contain last trial messages     </td></tr>
</table>


<h4>Notes:</h4>
<ul>
<li>System variables are global and are defined in core library;</li>
<li>You can define your own global variables in main module;</li>
<li>Prefix "$" is used to improve code readability;</li>
</ul>

<h2><a id="modules"/>Modules</h2>

<p>As we mentioned already Bee is modular. It means one large project can be split into parts. Each part can contain reusable rules. A module can load several other modules. An application need an entry point that orchestrate the program execution. This is called the "main" module. Below we explain each kind of module:</p>

<h3><a id="main"/>Main Modules</h3>
<p>Main module contains declarations for the <em>main rule</em>. One project can have one or more <em>main modules</em>. Each main module represent one single application.  Main module is located in the project root folder.</p>

<p><b>Notes:</b></p>
<ul>
<li>The main module can not be loaded, in other modules;</li>
<li>The main module do not have public members;</li>
<li>One project can have many main modules;</li>
<li>The main module can receive parameters;</li>
</ul>

<h3><a id="secondary"/>Secondary Modules</h3>
<p>A good designer will split a large problem into secondary modules. These modules are similar to the <em>main module</em> except they do not have the <em>main rule</em>. One secondary module can be used in one or more relate applications. Secondary modules are located in <em>src</em> folder. These modules can be loaded into other modules to be re-used.</p>

<p><b>Notes:</b></p>
<ul>
<li>Secondary modules are specific to a project;</li>
<li>Secondary modules should be loaded in other modules;</li>
<li>Secondary modules usually do not have rule main()
<li>Secondary modules usually have public members;</li>
</ul>


<h3><a id="library"/>Library Modules</h3>
<p>A <em>library module</em> is a file located in <em>"lib"</em> folder having extension *.bee. It is called simply: <em>module</em>. A library module can load other library modules and can execute its rules multiple times. You can install new libraries by downloading from the internet a package. Lib folder can have multiple sub-folders, where you create or modify a set of related libraries to be distributed for other people using a <em>package creator</em> tool.</p>

<h4>Notes:</h4>
<ul>
<li>Any <em>library module</em> should have public elements,</li>
<li>One <em>library module</em> can load multiple other library modules,</li>
<li>One <em>library module</em> do not contain rule main(),</li>
<li>One <em>library module</em> can be loaded a single time in another module,</li>
<li>You can not load a module from a block statement,</li>
<li>Library modules can be installed in: bee/lib folder for multiple projects</li>
</ul>

<div class="alert alert-warning"><b>Optional:&nbsp;</b>For small projects not have to declare secondary modules. Most Bee demo programs will not have multiple modules, however most Bee programs are using external libraries that belong to Bee, called "system modules".</div>

<h3><a id="main-rule"/>Main rule</h3>
<p>A module can define "rules". These are sub-programs that can be executed on demand. One special rule is the <em>main rule</em> that can be defined only in the main module. This rule can receive multiple parameters and is automatically executed when a program starts.</p>

<h4>Example:</h4>
<pre><code class="language-bee"># main rule
rule main(*params &isin; S):
   ** read the number of parameters
   new c := params.count;
   panic if (c = 0);

   ** print comma separated parameters
   new i:= 0 &isin; Z;
   while (i &lt; c) do
     write params[i];
     let i += 1;
     write "," if (i &lt; c);
   repeat;
   ** print the buffer to console
   print;
return;
</code></pre>

<p>Do not try to understand this example right now. It is just a warming-up code!</p>

<h4>Notes:</h4>
<ul>
<li>This program has a single module, that is main module;</li>
<li>Input parameter <em> *params</em> is an array of strings;</li>
<li>Early program termination can be trigger using: over or panic;</li>
<li>Any rule is ending with mandatory keyword: "<em>return</em>";</li>
</ul>

<h2><a id="external-code"/>External code</h2>

<p>Library modules that are reusable for multiple projects can be imported in Bee "lib" sub-folder. This folder is available in Bee as a system constant called: $bee_lib. You can install a set of libraries in a sub-folder of "$bee_lib". Then you can reuse external library by using "load" keyword. The folders can be concatenated using "." string operator.</p>

<h4>Pattern:</h4>

<pre><code class="language-bee"># loading modules
use $bee_lib.folder_name.(*);     -- load all modules from folder
use $bee_lib.folder_name.(x,y,z); -- load modules x.bee, y.bee and z.bee
</code></pre>

<h4>Notes:</h4>

<ul>
<li>using.(*) all modules from a folder are loaded in local scope;</li>
<li>using.(x,y,z) only some modules are loaded in local scope;</li>
<li>loaded modules, will merge all public elements in global scope;</li>
</ul>

<p><b>Qualifier</b>&nbsp;Bee can use <em> "dot notation"</em> to locate external members. This technique is used to avoid name collision if one library has names that collide with other library.</p>

<h4>Pattern:</h4>

<pre><code class="language-bee"># load a single module and create a qualifier
use  $bee_lib.folder_name.module_name as qualifier; -- load a single module
...
apply qualifier.member_name; -- using dot notation with qualifier
...
</code></pre>


<h4>Notes:</h4>
<p>1. A module can be loaded using a qualifier multiple times. However I do not see a useful use-case for this feature yet. I think is unusual to have same module loaded twice. It will be a waste of resources to do this.</p>
<p>2. All public members must use the specified qualifier or you can use "with" block to suppress the qualifier for a region of code. Using "with" is useful but sometimes not good enough so we have also invented the "alias".</p>

<h4>Examples:</h4>

<pre><code class="language-bee">#load examples
use cpp:$runtime.cpp_lib.(*); -- load cpp library
use asm:$runtime.asm_lib.(*); -- load asm library
use bee:$runtime.bee_lib.(*); -- load bee core library
use pro:$program.pro_lib.(*); -- load project library
</code></pre>

<h2><a id="global-scope"></a>Global scope</h2>

<p>One application has a global scope where variables and constants are allocated. Each secondary module can contribute with global variables and public elements that can be merged in this single scope. Global scope can be also called <em>application scope</em>;</p>

<ul>
<li>Global scope helps to use <em>public identifiers</em> from loaded modules;</li>
<li>When a module is loaded, its public members are defined in the <em>global scope</em>;</li>
<li>Public members of other modules can be used with quialifier.;</li>
</ul>

<h2><a id="name-space"></a>Name space</h2>
<p>A module has its own scope, that is called name-space where you can define members and statements. Module scope can contain public or private members. Public members start with "." while private members do not have any prefix or suffix.</p>

<pre><code class="language-bee">#define a module
module demo_module:

** public constant
set .pi: 3.14;

** expression rule foo is private
rule foo(x &isin; N) &isin; N =&gt; (x + 1);

** block rule bar is public
rule .bar(x, y &isin; N) =&gt; (r &isin; N):
  ** define local variable
  new str := "test";
  ...
  ** assign the result
  let r := x + y; -- r, x, y are locals
return;
</code></pre>

<h4>Loading:</h4>

<p>The main module can load numerous secondary modules or libraries. After loading, all public elements of a library can be accessed on demand using dot notation. You can not have collisions of names, except if you use "with" blocks. To simplify the code you can use "alias" statement and can rename a rule belonging to loaded modules.</p>

<p><b>Aliases:</b></p>
<p>You can create an alias for a specific member to eliminate the qualifier. This rule can be used to "merge" public members into current scope. A member can have one single alias in a module. If you do it multiple times, only the last alias is used. It is a bad practice to change the alias of a member.</p>

<h4>Pattern:</h4>

<pre><code class="language-bee">
** import library module
use library as qualifier

** create alias for a particular member
alias new_name: qualifier.member_name;
</pre></code>


<h4>Example:</h4>

<p>This example demonstrate how to use a rule from a module named "module_name"</p>
<pre><code class="language-bee">#define program name
** loading a module with qualifier
use $pro.src.demo_module as demo;

** give alias to module rule
alias sum = demo.bar;

** define main rule
rule main:
    ** call rule using qualifier
    new test := demo.bar(1,1); -- 2

    ** call rule using alias
    new result := sum(1,1); -- 2

    ** call rule using "with" block
    with demo do
         print foo(2);   -- 3
         print bar(2,1); -- 3
    done;
return;
</code></pre>

<p><b>Hiding: </b>To hide a public member instead of making an alias you can use keyword "hide". You can hide any public members from a loaded module. If you use a regular expression you can hide several public members that use a specific pattern.</p>

<pre><code class="language-bee">
hide qualifier.member_name;
hide qualifier.(reg_exp_pattern);
</code></pre>

<h2><a id="execution"/>Execution</h2>

<p>You can execute the public methods of a secondary module in two modes: synchronous mode and asynchronous mode. This is how you can split a large applications into smaller, more manageable parts that can be executed in parallel.</p>

<h4>Example:</h4>

<p>In next module called: "test_module.bee", we create a public rule that delay execution for several seconds using "wait" then it returns a result "r" equal to the argument value "t". So the rule basicity does nothing but wait.</p>

<pre><code class="language-bee"># secondary module: test_module.bee
rule .test(t &isin; Z) =&gt; (r &isin; N):
  let  r := t; -- prepare the result
  wait t;      -- wait for t seconds
return;
</code></pre>

<h4>1. Synchronous call using: apply</h4>

<p>Let's use the module previously defined in synchronous mode.</p>

<pre><code class="language-bee"># main module
use $pro_src.test_module;

alias test = test_module.test;

+--------------------------------
execute test() and append result
at the end of "collect" list
--------------------------------+
rule main:
   ** define a collector (list)
   new collect &isin; (N);

   apply collect &lt;+ test(30);
   apply collect &lt;+ test(40);
   apply collect &lt;+ test(10);
   apply collect &lt;+ test(20);

   ** the collector is unordered
   print collect; -- (30,40,10,20)
return;</code></pre>

<h4>2.Asynchronous call using: begin</h4>

<p>Let's use the module previously defined in asynchronous mode. For this we use keywords "begin" to start a process and "wait" for all asynchronous sub-processes to synchronize.</p>

<pre><code class="language-bee"># main module
use $pro_src.test_aspect.(*);

+-----------------------------------------
   execute test() and append result
   at the end of "collect" list
-----------------------------------------+
rule main:
   ** define a collector (list)
   new collect &isin; (N);

   begin collect &lt;+ test(30); -- open one thread
   begin collect &lt;+ test(40); -- open one thread
   begin collect &lt;+ test(10); -- open one thread
   begin collect &lt;+ test(20); -- open one thread

   wait; -- stop and wait for the all open threads to finish

   ** the collector is ordered
   print collect; -- (10,20,30,40)
return;</code></pre>

<p><b>Note:&nbsp;</b>By using begin and wait you can create multi-session applications. Each aspect is executed on a different core, and the application runs them in parallel. The main thread is waiting using resolve keyword for the threads to finish.
<p>

<hr>

<p><b>Read next:</b>
<a href="/bee/types/">Data Types</a></p>
<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>