<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Bee specification: syntax overview.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="bee, language, syntax, overview, expressions">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Website title -->
  <title>Bee Syntax</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Bee Highlighter -->
  <script src="js/bee.js"></script>
  <!-- Sage-Code CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="bee_render()">
<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.pro"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>

<h1>Bee Syntax</h1>

<div class="alert alert-secondary shadow-sm">
  Bee is not a curly bracket language. Its syntax is inspired from Ada, Ruby, Fortran and Julia. We have created an imperative programming language with original front-end.</div>

<h4>Page bookmarks:</h4>

<p>Next we enumerate the fundamental concepts to grasp Bee syntax. After this overview we will go in details. We use long pages you can scroll. Here are the main topics for this page:</p>

<ul>
<li><a href="#comments">Comments</a></li>
<li><a href="#keywords">Keywords</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#statements">Statements</a></li>
<li><a href="#conditions">Conditions</a></li>
<li><a href="#operators">Operators</a></li>
</ul>

<h4>Legend:</h4>

<p>We use examples and sometimes a simplified version of BNF notation to explain the syntax rules. If you do not know anything about BNF don't wary, here is a short introduction to this weird notation:</p>

<ul>
<li>We use suggestive descriptors for language elements,</li>
<li>We use "::=" to explain a descriptor,</li>
<li>We use "..." for repetitive sequences of symbols,</li>
<li>We use notes to explain the semantics,</li>
<li>Optional keyword is enclosed in square brackets [];</li>
</ul>

<h2><a id="comments"</a>Comments</h2>
<p>Comments are very important part of Bee code. We have multiple conventions for making good comments for any project. Bee comments are tailored by architectural principle: "if there are no comments in the code the code is wrong." </p>

<h4>Example:</h4>
<p>In next example we are using various comments into a demo program.</p>
<pre><code class="language-bee">#!/bin/bee
+------------------------------------------------------------------
| At the beginning of program you can have  several comments,     |
| to explain how the program works. This notation is preferred.   |
+-----------------------------------------------------------------+
rule main:
  continue; -- this statement does nothing

  ** this is a single line comment
  print ("end of line comments",    -- first argument
         "can be used to explain",  -- second argument
         "diverse arguments"        -- third argument
        );
return;
*******************************************************************
** This is the old style boxed comment, used for matrix printers **
** In Bee you can add comments/notes at the end of your code     **
*******************************************************************
</code></pre>

<h4>Title comment</h4>

<p>For single line title comments we use one "#" symbol. This can be used in combination with "!" to create "shebang" comment known in scripting languages on Linux to specify interpreter location. You can use two "##" for subtitles for large code sections.</p>

<h4>Single line</h4>
<p>For single line comments we use two stars like this: "**";</p>
<ul>
<li>This comment can be extended to multiple stars to create a separator,</li>
<li>You can use single line comment at beginning of new line,</li>
<li>You can use two spaces to indent the comment and align with the code.</li>
</ul>

<h4>End of line</h4>
<p>Before new line of code: (EOL) you can use comments starting with: "-- "</p>
<ul>
<li>notice one line may be or not a full statement. the end of statement is not (EOL),</li>
<li>you can use "-- " in the middle of an expression, if expression is on multiple lines,</li>
<li>you can have multiple statements separated by ";" in a line but only one comment.</li>
</ul>

<h4>Box comment</h4>
<p>Bee has a specific notation for block comments not used in any other language so far. It is a multi-line comment starting with "+-" and end with "-+". The upper right corner is missing. I guess you will notice this defect later. However you can use old-style C comments.</p>

<h4>Notes:</h4>
<ul>
<li>Bee comments are inspired from Ada language and Wiki markdown</li>
<li>Bee comments are designed for better syntax coloring</li>
</ul>

<h2><a id="keywords"/>Bee Keywords</h2>

<p>Bee is an expressive language but it's core has about 72 reserved keywords so far:</p>

<table class="table table-bordered table-dark table-hover table-sm shadow">
<tr><td>begin  </td><td>alias </td><td>and     </td><td>apply </td><td>abort  </td></tr>
<tr><td>other  </td><td>case  </td><td>continue</td><td>done  </td><td>default</td></tr>
<tr><td>if     </td><td>is    </td><td>do      </td><td>else  </td><td>exit   </td></tr>
<tr><td>fail   </td><td>final </td><td>miss   </td><td>panic </td><td>like   </td></tr>
<tr><td>load   </td><td>next  </td><td>job     </td><td>match </td><td>over   </td></tr>
<tr><td>print  </td><td>pass  </td><td>void    </td><td>rule  </td><td>return </td></tr>
<tr><td>fail   </td><td>retry </td><td>none    </td><td>scrap </td><td>type   </td></tr>
<tr><td>read   </td><td>trial </td><td>stop    </td><td>yield </td><td>xor    </td></tr>
<tr><td>write  </td><td>wait  </td><td>when    </td><td>or    </td><td>with   </td></tr>
<tr><td>hide   </td><td>new   </td><td>cycle   </td><td>let   </td><td>set  </td></tr>
<tr><td>while  </td><td>for   </td><td>resum   </td><td>put   </td><td>pop     </td></tr>
<tr><td>raise  </td><td>not   </td><td>as   </td><td>in   </td><td>start   </td></tr>
<tr><td>try  </td><td>expect  </td><td>     </td><td>   </td><td>  </td></tr>
</table>

<h4>Notes:</h4>
<ul>
<li>You can not use these keywords as identifiers;</li>
<li>Some of these keywords are reserved but not implemented;</li>
<li>New keywords are going to be created for new features;</li>
</ul>


<h3><a href="#semantic-keywords"></a>Semantic keywords</h3>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Keyword</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>if</td>
<td>conditional executor for one statement block</td>
</tr>
<tr>
<td>is</td>
<td>query element or variable data type</td>
</tr>
<tr>
  <td>as</td>
  <td>create alias for used modules</td>
</tr>
<tr>
<td>or</td>
<td>alternative for ladder decision</td>
</tr>
<tr>
<td>in</td>
<td>alternative for belong operation</td>
</tr>
<tr>
<td>and</td>
<td>alternative for cascade decision</td>
</tr>
<tr>
<td>xor</td>
<td>alternative for logic operation</td>
</tr>
<tr>
<td>not</td>
<td>alternative for logic operation</td>
</tr>
</tbody>
</table>

<h2><a id="statements"/>Statements</h2>
<p>Statements can start with imperative keyword or a declarative keyword:</p>

<h4>Examples:</h4>
<table class="table table-bordered table-sm table-striped">
<tr><td width="15%" class="fixed">set   </td><td>create a constant  </li>
<tr><td width="15%" class="fixed">new   </td><td>create a variable  </li>
<tr><td width="15%" class="fixed">let   </td><td>modify a variable  </li>
<tr><td width="15%" class="fixed">type  </td><td>create a data type </li>
<tr><td width="15%" class="fixed">read  </td><td>accept input from console into a variable     </li>
<tr><td width="15%" class="fixed">write </td><td>register in console cash a string             </li>
<tr><td width="15%" class="fixed">print </td><td>output to console with end of new line        </li>
</table>

<h4>Notes:</h4>
<ul>
<li>One statement is usually indented 2 space,</li>
<li>One statement is usually described in a single line,</li>
<li>Multiple statements on a single line are separated with ";",</li>
<li>One expression in a statement can extend on multiple lines.</li>
</ul>
<h3><a id="code-blocks"/>Code blocks</h3>
<p>Statements can be contained in blocks of code.</p>

<table class="table table-bordered table-sm table-striped">
<tr><th> Keyword </th><th> Block description </th></tr>
<tr><td class="fixed">start </td><td>start local scope for do block</td></tr>
<tr><td class="fixed">with  </td><td>qualifier suppression block</td></tr>
<tr><td class="fixed">if    </td><td>first block in decision statement</td></tr>
<tr><td class="fixed">cycle </td><td>repetitive or iterative blocks</td></tr>
<tr><td class="fixed">match </td><td>multi-path value selector block</td></tr>
<tr><td class="fixed">trial </td><td>exception handler block</td></tr>
</table>

<h4>Notes:</h4>
<ul>
<li>Block ending keyword can be one of: { done, cycle },</li>
<li>Statements in nested blocks are using indentation.</li>
</ul>

<h3><a href="#definition-statements"></a>Definition statements</h3>
<p>Next statements are used to declare new elements in a module.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Keyword</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>use</td>
<td>Load module or module</td>
</tr>
<tr>
<td>alias</td>
<td>Eliminate scope qualifier</td>
</tr>
<tr>
<td>hide</td>
<td>Hiding public members from a loaded module</td>
</tr>
<tr>
<td>rule</td>
<td>Create a new <em>business rule</em> or <em>prototype</em></td>
</tr>
<tr>
<td>return</td>
<td>End <em>rule</em> declaration and transfer control to caller</td>
</tr>
</tbody>
</table>

<h3><a href="#execution-statements"></a>Execution statements</h3>
<p>Next keywords are simple statements. These represents actions called <em>imperative statements</em>.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Keyword</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>apply</td>
<td>Execute a <em>rule</em> and ignore the <em>result</em> if there is one</td>
</tr>
<tr>
<td>begin</td>
<td>Commence execution of a coroutine</td>
</tr>
<tr>
<td>wait</td>
<td>Suspend current thread execution for a number of seconds</td>
</tr>
<tr>
<td>read</td>
<td>Flush the console buffer and accept user input from console</td>
</tr>
<tr>
<td>write</td>
<td>Add something to console buffer but no new line</td>
</tr>
<tr>
<td>print</td>
<td>Output expression result, variable or constant to console</td>
</tr>
<tr>
<td>let</td>
<td>Mutate variable value using an expression</td>
</tr>
<tr>
<td>scrap</td>
<td>Remove one element from its collection</td>
</tr>
</tbody>
</table>

<h2><a href="#control-statements"></a>Control statements</h2>
<p>Control statements are used to create local blocks of code that resolve a small task synchronously. After task is finished the control is returned to the main thread.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Keyword</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td>Create non repetitive local scope</td>
</tr>  
<tr>
<td>if</td>
<td>Start a conditional branch</td>
</tr>
<tr>
<td>else</td>
<td>Start an alternative branch</td>
</tr>   
<tr>
<td>do</td>
<td>Start a block of code</td>
</tr> 
<tr>
<td>cycle</td>
<td>Create repetitive local scope</td>
</tr> 
<tr>
<td>for</td>
<td>Create finite iterative block</td>
</tr> 
<tr>
<td>while</td>
<td>Create conditional repetitive block</td>
</tr> 
<tr>
<td>match</td>
<td>Value multi-path search selector</td>
</tr>
<tr>
<td>when</td>
<td>Create node for match statement</td>
</tr>
<tr>
<td>other</td>
<td>Default branch for match statement</td>
</tr>
<tr>
<td>trial</td>
<td>Start declaration region for a protected block of code</td>
</tr>
<tr>
<td>try</td>
<td>Begin the executable region in a trial statement</td>
</tr>
<tr>
<td>case</td>
<td>Associated with trial to resolve specific errors</td>
</tr>
<tr>
<td>miss</td>
<td>Default trial block, executed when there is no case</td>
</tr>
<tr>
<td>final</td>
<td>Associated with trial to finalize the trial block</td>
</tr>
</tbody>
</table>

<h2>Transfer statements</h2>
<p>These statements execute a jump or make an interruption of current thread.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Keyword</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>panic</td>
<td>Create unrecoverable error code and stop current program</td>
</tr>
<tr>
<td>over</td>
<td>Silent termination of program. No error is raised in this case.</td>
</tr>
<tr>
<td>exit</td>
<td>Silently stop execution of current rule and return to the caller</td>
</tr>
<tr>
<td>yield</td>
<td>Suspend one coroutine and give control to another routine</td>
</tr>
<tr>
<td>rest</td>
<td>Suspend a routine and wait for all threads created by the routine to finish</td>
</tr>
<tr>
<tr>
<td>stop</td>
<td>Interrupt execution for current cycle and continue after the cycle,</td>
</tr>
<tr>
<td>redo</td>
<td>Continue current cycle from the beginning making a shortcut,</td>
</tr>
<tr>
<td>next</td>
<td>Continue current iteration from the beginning making a shortcut,</td>
</tr>
<tr>
<td>abort</td>
<td>stop early a trial block</td>
</tr>
<tr>
<td>fail</td>
<td>Create error message and continue with next step</td>
</tr>
<tr>
<td>pass</td>
<td>Skip the rest and continue with next step</td>
</tr>
<tr>
  <td>expect</td>
  <td>Does nothing if condition is true, otherwise create an $unexpected exception</td>
</tr>
<tr>
<td>raise</td>
<td>Intrerupt a try job or trial and issue an error</td>
</tr>
<tr>
<td>retry</td>
<td>Repeat a trial block from the begioning</td>
</tr>
<tr>
<td>resume</td>
<td>Mark error as handled and continue trial</td>
</tr>
<tr>
  <td class="fixed">done  </td>
  <td>end a block statement</td>
</tr>
<tr>
  <td class="fixed">repeat  </td>
  <td>end a repetitive block</td>
</tr>
</tbody>
</table>

<h4>Identifiers:</h4>

<p>Bee identifiers can start with dolar ($), dot (.), underscore (_), Latin, Greek, Chyrillic. An identifier can contain numbers but can not start with a number.</p>

<h4>Unicode letters:</h4>

<p>In mathematics is very popular notation for angles to use Greek letters. We support in Bee a limited number of Greek an Cyrillic letters for identifiers:</p>

<pre class="language-out">
Σ Π Δ Ξ Γ Ψ Ω ζ
α β ɣ λ π μ φ ε δ η σ ω
Б Г Д Ж И Л Ф Ц Ч Ш Э Я 
</pre>

<h3>Subscript:</h3>

<p>You can use a limited number of letters and numbers available in Unicode as subscript to make identifier names. You can not start an identifier with one of these symbols and you can't add other symbols that are not subscript after a subscript:</p>

<pre class="language-out">
x₀ x₁ x₂ x₃ x₄ x₅ x₆ x₇ x₈ x₉ x₁₀
yₐ yₑ yₕ yᵢ yⱼ yₖ yₗ yₘ yₙ yₒ yₚ yᵣ yₛ yₜ yᵤ yᵥ yₓ

</pre>

<h3>Superscript:</h3>

<p>Bee has support for exponent using superscript. You can make any integer exponent including negative numbers but you can not use dot or fraction in the exponent.<p>

<pre class="language-out">
x⁺ x⁻ x¹ x² x³ x⁴ x⁵ x⁶ x⁷ x⁸ x⁹ x¹⁰
</pre>

<p><b>Note: </b>
Symbol (^) is exponent operator and is not required when you use superscript exponent. You can use it with expressions, constants or rational numbers to resolve the exceptional cases.</p>

<h4>Lowercase exponent:</h4>

<p>Identifiers that start with a lowercase Latin letter can be used as exponent. The superscript variable can start with a letter and can also use numbers.</p>

<pre class="language-out">
yᵃ yᵇ yᶜ yᵈ yᵉ yᶠ yᵍ yʰ yⁱ yʲ yᵏ yᶩ 
yᵐ yⁿ yᵒ yᵖ yʳ yˢ yᵗ yᵘ yᵛ yʷ yˣ yʸ yᶻ
</pre>

<h4>Uppercase exponent:</h4>

<p>If you define a constant or variable that start with capital letter there may be some issues. You can't use all Latin letters or any Greek or Cyrilic capital letters in exponent. So your options are limited to create uppercase exponents.</p>

<pre class="language-out">
zᴬ zᴮ zᴰ zᴱ zᴲ zᴳ zᵸ zᴵ zᴶ zᴷ zᴸ 
zᴹ zᴺ zᴻ zᴼ zᴾ zᴿ zᵀ zᵁ zᵂ
</pre>
<br>
<div class="alert alert-warning"><b>Caution: </b>Observe letters: {C, F ,S ,Q} are missing. So if you define a constant that use any of these letters, you will need symbol (^) to create exponent.</div>

<h2><a id="variables"/>Variable declarations</h2>

<p>In Bee, all variables must be declared using an imperative statement. Variables can be dynamic or static and can have a data type. Data type can be custom or pre-defined.</p>

<table class="table table-bordered table-sm table-striped">
<tr>
  <td width="15%">type</td>
  <td>declare custom data type</td>
</tr>
<tr>
  <td width="15%">new</td>
  <td>declare a dynamic variable</td>
</tr>
<tr>
  <td width="15%">set</td>
  <td>declare a static variable</td>
</tr>
</table>

<h2><a id="expressions"></a>Expressions</h2>

<p>Expressions are created using identifiers, operators, rules and constant literals. Expressions can be anonymous or can be assigned to identifiers to create lambda expressions.</p>

<p>expressions ...</p>
<ul>
<li>can use () to establish order of operations,</li>
<li>can be enumerated using comma separator "," in a list,</li>
<li>can be combined to create more complex expressions,</li>
</ul>

<h4>Examples</h4>

<pre><code class="language-bee linenumbers">** expressions
print 10
print 10 + 10 + 15
print "this is a test"

** complex expressions
print (10 &gt; 5) &or; (2 &lt; 3)
print -b + sqr(b² - 4·a·b)/(2·a)

** enumeration of expressions
print (1,2,3)
print (1,',',2,',',3)
</code></pre>

<h2><a id="conditions"/>Conditional Execution</h2>

<p>A condition is a logic expression used to control statement execution. For this we use {"if", "else"} keywords at end of statements.</p>

<pre><code class="language-bee">
** conditional statement execution
statement if condition;
</code></pre>

<p><b>Note:</b> Previous statement is executed only if the condition is True.</p>

<pre><code class="language-bee">
** alternative statement 
  expect condition else statement;

** alternative expression
  expect condition else expression;
</code></pre>

<p><b>Note:</b> Previous statement is executed only if the condition is False.</p>

<p><b>restrictions:</b></p>
<ol>
<li>Can not use "if" with set statement;</li>
<li>Can not use "if" with new statement;</li>
<li>Can not use "if" after done;</li>
</ol>

<h4>Example:</h4>

<pre><code class="language-bee">
rule main:
  ** generate a random number
  new a := random(Z);

  ** conditional execution
  new b := a;
  let b := -a if a < 0;

  ** print result
  print "|b| = ", a;
return;
</code></pre>

<h4>Operations:</h4>

<p>Bee has support for fractions. Bee is using regular slash "/" for all fractions. You can use superscript for left and subscript for right: These two are equivalent (1/2 = ¹/₂). Unfortunately we can not support fractional power due to lower readability.</p>

<pre class="language-out">
¹/₂ ¹/₃ ¹/₄ ¹/₅ ¹/₆ ¹/₇ ¹/₈ ¹/₉  ¹/₁₀ ¹/₁₀₀
x⁻¹ = 1/x, x⁻² = 1/x², x⁻³ = 1/x³ ...
</pre>

<p>Power operations have priority but we have support only for (+, -) no other operations are possible in exponent. In next expressions, (n-1) is done first before making the power operation.</p>

<pre class="language-out">
-- equivalent notation
xⁿ⁻¹ = x^(n-1)
xˣ⁺¹ = x^(n+1)

-- equivalent  notation
x^(¹/₂) = √2(x)  
x^(¹/₃) = √3(x) 
</pre>
<br>
<div class="alert alert-warning"><b>Note:</b>In expressions above () symbols are mandatory. The compiler will detect missing paranthesis and will ask for it. This will improve code readability and eliminate confusions.</div>

<h3>Pattern Matching</h3>

<p>Instead of ternary operator we use conditional expressions. Conditional expressions enable many choices unlike ternary operator that enable only 2 choices. Conditional expressions are also known as pattern matching expressions.</p>

<h4>Syntax:</h4>
<pre><code class="language-bee">
rule main:
  ** define a local variable
  new var &isin; type;

  ** single condition matching
  let var := (xp1 if cnd1 else xp);

  ** multiple matching with default value
  let var := (xp1 if cnd1, xp2 if cnd2,..., xp);

  ** alternative code alignment
  let var := ( xp1 if cnd1 else
               xp2 if con2 else
               xp3 if cnd3 else
               xp
              );
return;
</code></pre>

<h4>Example:</h4>
<pre><code class="language-bee">rule main:
   new x := '0'; -- symbol
   write "x:"
   read   x;

   new kind := ("digit"  if x &isin; ['0'..'9'] else
                "letter" if x &isin; ['a'..'z'] else
                "unknown");

   print ("x is " + kind); -- expect: "x is digit"
return;
</code></pre>

<h2><a id="operators"/>Operators</h2>

<p>Bee operators are ASCII or Unicode symbols. One operator can be created using one or two characters. This is why Bee language is considered experimental, esoteric & disruptive.</p>

<h2>Delimiters</h2>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>+-...-+</td>
<td>Multi-line boxed comments</td>
</tr>
<tr>
<td>#(....)</td>
<td>String interpolation (placeholder) for operator "?"</td>
</tr>
<tr>
<td>(_,_,_)</td>
<td>Expression | List literal</td>
</tr>
<tr>
<td>[_,_,_]</td>
<td>Index | Array literals | Parameterize types</td>
</tr>
<tr>
<td>{_,_,_}</td>
<td>Enumeration type | Set of values | Hash map</td>
</tr>
</tbody>
</table>
<h2>Strings</h2>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`x`</td>
<td>Back quoted string: regular expression.</td>
</tr>
<tr>
<td>'x'</td>
<td>Single quoted string literal or ASCII code point</td>
</tr>
<tr>
<td>"y"</td>
<td>Double quoted string literal or UTF32 code point</td>
</tr>
</tbody>
</table>

<h2>Single Symbols</h2>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>Negation symbol for relations | Excluded from domain</td>
</tr>
<tr>
<td>?</td>
<td>Template modifier. Associated with string templates</td>
</tr>
<tr>
<td>*</td>
<td>String replication | Varargs prefix | Spread operator | Many something</td>
</tr>
<tr>
<td>@</td>
<td>Domain name | Example @sagecode.net</td>
</tr>
<tr>
<td>$</td>
<td>System constant | Environment variables</td>
</tr>
<tr>
<td>&amp;</td>
<td>String concatenation | number concatenation</td>
</tr>
<tr>
<td>#</td>
<td>Title | String interpolation </td>
</tr>
<tr>
<td>&isin;</td>
<td>Define variable/constant/result/parameter type</td>
</tr>
<tr>
<td>_</td>
<td>Anonymous variable | Constant value = one space (_ = ' ')</td>
</tr>
<tr>
<td>+</td>
<td>Maximum upper limit for a domain | Unicode notation U+</td>
</tr>
<tr>
<td>-</td>
<td>Minimum lower limit in a domain | Unicode notation U-</td>
</tr>
<tr>
<td>:</td>
<td>Start a block or define something</td>
</tr>
<tr>
<td>:</td>
<td>Pair-up key-value in: objects, rule parameters, rule arguments, hash-map pairs</td>
</tr>
<tr>
<td>;</td>
<td>End of statement | Statement separator</td>
</tr>
<tr>
<td>.</td>
<td>Decimals for real numbers | Path string concatenation</td>
</tr>
<tr>
<td>.</td>
<td>Membership dot notation | Prefix for public member/attribute</td>
<tr>
<td>,</td>
<td>Enumeration of elements | expressions</td>
</tr>
<tr>
<td>|</td>
<td>Declarative collection builder: set := { x*2 | x &isin; (0..3)}</td>
</tr>
<tr>
<td>\</td>
<td>Escape character (&nbsp;\n&nbsp;:= New Line), (&nbsp;\"&nbsp;= Double Quotes)</td>
</tr>
</tbody>
</table>
<h2>Numeric operators</h2>
<p>Listed in the order of precedence top down.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>Change sign, replace "y = -x" with "y = -1*x"</td>
</tr>
<tr>
<td>/</td>
<td>Rational number division</td>
</tr>
<tr>
<td>^</td>
<td>Power symbol used with fractions or expressions</td>
</tr>
<tr>
<td>√</td>
<td>Radical: x√n is equivalent to x^(1/n)</td>
</tr>
<tr>
<td>*</td>
<td>Multiplication alternative</td>
</tr>
<tr>
<td>\</td>
<td>Rational number division</td>
</tr>
<tr>
<td>/</td>
<td>Real number division</td>
</tr>
<tr>
<td>&times;</td>
<td>Array multiplication | Matrix multiplication</td>
</tr>
<tr>
<td>%</td>
<td>Modulo operator 5 % 2 = 2</td>
</tr>
<tr>
<td>+</td>
<td>Numeric addition | List append | Matrix addition</td>
</tr>
<tr>
<td>-</td>
<td>Numeric subtraction | Collection difference</td>
</tr>
<tr>
<td>&plusmn;</td>
<td>Numeric tolerance (use with &asymp;)</td>
</tr>
</tbody>
</table>

<h2>Double Symbols</h2>

<p>Double symbols is a group of two ASCII symbols considered as one. Some of these symbols have an Unicode equivalent, some do not. When available, Unicode equivalent is preferred choice.</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-- </td>
<td>End of line comments (not in expression)</td>
</tr>
<tr>
<td>##</td>
<td>Single line subtitle comments (no indentation)</td>
</tr>
<tr>
<td>**</td>
<td>Single line comments (allow indentation)</td>
</tr>
<tr>
<td>..</td>
<td>Define range/domain/slice (n..m) | [n..m]</td>
</tr>
<tr>
<td>.!</td>
<td>Define range/domain with excluded limit (n.!m) | [n.!m]</td>
</tr>
<tr>
<td>!.</td>
<td>Define range/domain with excluded limit (n!.m) | [n.!m] </td>
</tr>
<tr>
<td>!!</td>
<td>Define range/domain with excluded limits: (n!!m) | [n.!m] </td>
</tr>
<tr>
<td>-.</td>
<td>Minus infinite domain: instead of [-&infin;..0] write: [-..0]</td>
</tr>
<tr>
<td>.+</td>
<td>Plus infinite domain: instead of [0..+&infin;] write: [0..+]</td>
</tr>
<tr>
<td>=&gt;</td>
<td>Define: rule expression | rule result</td>
</tr>
<tr>
<td>&lt;-</td>
<td>Define and generate values in a loop from range or set</td>
</tr>
<tr>
<td>&lt;:</td>
<td>Define subset from set | Specify super-type for a new type</td>
</tr>
<tr>
<td>:&gt;</td>
<td>Data cast pipeline operator / Type conversion</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>Shift values of collection to right by removing first elements</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Shift values of collection to left by removing first elements</td>
</tr>
<tr>
<td>::</td>
<td>Deep copy | Clone operator</td>
</tr>
<tr>
<td>++</td>
<td>Extend an array with one or more elements</td>
</tr>
<tr>
<td>-=</td>
<td>Find and delete one element, from a collection</td>
</tr>
<td>+=</td>
<td>Append an element in a set or a map but not in a list</td>
</tr>
<tr>
<td>+&gt;</td>
<td>Append element to beginning of a list</td>
</tr>
<tr>
<td>&lt;+</td>
<td>Append element to end of a list</td>
</tr>
<td>==</td>
<td>Relation operator for identical (the same)</td>
</tr>
<td>!=</td>
<td>Relation operator not identical (not the same)</td>
</tr>
<tr>
<td>~=</td>
<td>Relation operator: regular expression match</td>
</tr>
<tr>
<td>>=</td>
<td>Relation operator: greater then or equal to</td>
</tr>
<tr>
<td><=</td>
<td>Relation operator: less then or equal to</td>
</tr>
</tbody>
</table>

<h2>Modifiers</h2>
<p>Each modifier is created with pattern "x=" where x is a single symbol:</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>:=</td>
<td>Modify | (value | reference)</td>
</tr>
<tr>
<td>+=</td>
<td>Increment value</td>
</tr>
<tr>
<td>-=</td>
<td>Decrement value</td>
</tr>
<tr>
<td>*=</td>
<td>Multiplication modifier</td>
</tr>
<tr>
<td>/=</td>
<td>Real division modifier</td>
</tr>
<tr>
<td>^=</td>
<td>Power modifier</td>
</tr>
<tr>
<td>√=</td>
<td>Radical modifier</td>
</tr>
<tr>
<td>%=</td>
<td>Modulo modifier</td>
</tr>
</tbody>
</table>

<h2>Relation Operators</h2>
<p>Relation operators are used to compare expressions.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>&isin;</td>
<td>check if element belong to collection</td>
</tr>
<tr>
<td>=</td>
<td>equal { compare values or attributes}</td>
</tr>
<tr>
<td>&ne;</td>
<td>different { compare values or attributes}</td>
</tr>
<tr>
<td>&equiv;</td>
<td>equivalent | { compare values / convert type }</td>
</tr>
<tr>
<td>&asymp;</td>
<td>approximating equal numbers, used with&nbsp;&plusmn;&nbsp;like: (x &asymp; 4 &plusmn; 0.25)</td>
</tr>
<tr>
<td>&gt;</td>
<td>value is greater than: (2 &gt; 1)</td>
</tr>
<tr>
<td>&lt;</td>
<td>value is less than: (1 &lt; 2)</td>
</tr>
<tr>
<td>&ge;</td>
<td>greater than or equal to</td>
</tr>
<tr>
<td>&le;</td>
<td>less than or equal to</td>
</tr>
<td>&divide;</td>
<td>Exact divisor: 3 &division; 15 &equiv; True</td>
</tr>
</tbody>
</table>

<p><strong>negation:</strong></p>
<p>Operator: "!" can be used in combination with other operators:</p>
<pre class="language-out">
 x != y; -- equivalent to: &not;(x = y)
 x !&equiv; y; -- equivalent to: &not;(x &equiv; y)
 x !&isin; y; -- equivalent to: &not;(x &isin; y)
 x !&asymp; y; -- equivalent to: &not;(x &asymp; y)
 x !~ y; -- equivalent to: &not;(x ~ y)
</pre>
<h2>Collection operators</h2>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>result</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>&cap;</td>
<td>Set</td>
<td>Intersection between two collections</td>
</tr>
<tr>
<td>&cup;</td>
<td>Set</td>
<td>Union between two collections</td>
</tr>
<tr>
<td>&sub;</td>
<td>Logic</td>
<td>Set is included in superset: "&sub;"</td>
</tr>
<tr>
<td>&sup;</td>
<td>Logic</td>
<td>Set contain subset: "&sup;"</td>
</tr>
<tr>
<td>&Delta;</td>
<td>Set</td>
<td>Set symmetric difference</td>
</tr>
<tr>
<td>+</td>
<td>String</td>
<td>Concatenation between two strings</td>
</tr>
<tr>
<td>+</td>
<td>List</td>
<td>Concatenation between two lists</td>
</tr>
<tr>
<td>+</td>
<td>Array</td>
<td>Concatenation between two arrays</td>
</tr>
<tr>
<td>&forall;</td>
<td>Element</td>
<td>All: used in collection qualification</td>
</tr>
<tr>
<td>&exist;</td>
<td>Logic</td>
<td>One: used in collection qualification</td>
</tr>
</tbody>
</table>
<h2>Logic Operators</h2>
<p>Bee is using enumeration symbols: True = 1 and False = 0</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
<th>notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>&not;</td>
<td>NOT</td>
<td>unary operator</td>
</tr>
<tr>
<td>∧</td>
<td>AND</td>
<td>shortcut operator</td>
</tr>
<tr>
<td>&or;</td>
<td>OR</td>
<td>shortcut operator</td>
</tr>
<tr>
<td>&oplus;</td>
<td>XOR</td>
<td>exclusive OR</td>
</tr>
<tr>
<td>&darr;</td>
<td>NOR</td>
<td>p &darr; q = &not; (p &or; q)</td>
</tr>
<tr>
<td>&uarr;</td>
<td>NAND</td>
<td>p &uarr; q = &not; (p ∧ q)</td>
</tr>
</tbody>
</table>

<h4>The table of truth</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>&not; p</th>
<th>p &oplus; q</th>
<th>p ∧ q</th>
<th>p &or; q</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

<h2>Bitwise operators</h2>

<p>Bitwise operators are processing numbers not Boolean values.</p>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
<th>notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>&laquo;</td>
<td>bit SHIFTL</td>
<td>shift bits to left</td>
</tr>
<tr>
<td>&raquo;</td>
<td>bit SHIFTR</td>
<td>shift bits to right</td>
</tr>
<tr>
<td>~</td>
<td>bit NOT</td>
<td>negate all bits</td>
</tr>
<tr>
<td>&amp;</td>
<td>bit AND</td>
<td>execute AND between each bits</td>
</tr>
<tr>
<td>|</td>
<td>bit OR</td>
<td>execute OR between each bits</td>
</tr>
<tr>
<td>&oplus;</td>
<td>bit XOR</td>
<td>execute XOR between each bits</td>
</tr>
</tbody>
</table>
<!-- todo check bit manipulation article to inject some content here
"https://en.wikipedia.org/wiki/Bit_manipulation" rel="nofollow"-->

<h4>Arity = 1</h4>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>a</th>
<th>~ a</th>
<th>a &laquo; 1</th>
<th>a &raquo; 2</th>
</tr>
</thead>
<tbody>
<tr><td>0000</td><td>1111</td><td>0000</td><td>0000</td></tr>
<tr><td>1111</td><td>0000</td><td>1110</td><td>0011</td></tr>
<tr><td>0111</td><td>1000</td><td>1110</td><td>0001</td></tr>
<tr><td>0110</td><td>1001</td><td>1100</td><td>0001</td></tr>
</tbody></table>

<h4>Arity = 2</h4>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>a</th><th>b</th><th>a &amp; b</th><th>a | b</th><th>a &oplus; b</th></tr>
</thead>
<tbody>
<tr><td>00</td><td>00</td><td>00</td><td>00</td><td>00</td></tr>
<tr><td>01</td><td>00</td><td>00</td><td>01</td><td>01</td></tr>
<tr><td>11</td><td>01</td><td>01</td><td>11</td><td>10</td></tr>
<tr><td>10</td><td>11</td><td>10</td><td>11</td><td>01</td></tr>
</tbody>
</table>

<h2>String operators</h2>
<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Symbol</th><th>Description</th>
</tr>
</thead>
<tbody>
<tr><td>*</td><td>string pattern repetition (right operator must be numeric)</td></tr>
<tr><td>/</td><td>concatenate url or path using / not depending on OS</td></tr>
<tr><td>+</td><td>concatenate two strings as they are preserving trial spaces.</td></tr>
<tr><td>-</td><td>concatenate two strings and trim spaces to a single space.</td></tr>
<tr><td>.</td><td>concatenate strings with "/" on Linux or "\" on Windows.</td></tr>
<tr><td>?</td><td>string format operator, replace "#" with number.</td></tr>
</tbody>
</table>

<!-- work in progress-->
<hr>

<p><b>Read next:</b>
<a href="structure.html">Structure</a></p>
<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>