<html lang="en" data-bs-theme="dark"><head>
  <meta charset="utf-8">
  <meta name="description" content="Bee type system.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, bee, types">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Website title -->
  <title>Bee Types</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="/images/favicon.ico">
  <!-- Bee Highlighter -->
  <script src="/bee/js/bee.js"></script>
  <!-- Sage-Code CSS -->
  <link rel="stylesheet" href="/sage.css">
  </head>
<body onload="bee_render()">
<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.pro"><img src="/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
       <div class="col text-end align-self-center">
        <a href="/bee/index.html#lang-index" rel="nofollow" rel="nofollow">index</a>
    </div>
</div><hr>

<h1>Bee Types</h1>
<div class="alert alert-secondary shadow-sm">
Data types represent a <em>domains of values</em>. In other words, data type represent constraints that can be used to validate a particular value. Data<em>"type"</em> is an attribute of any data value.</div>

<p>Bee use several kind of data types described below. Use these links to jump to a particular data type. Use browser back-button to revisit a particular data type:</p>
<ol>
<li><a href="#primitive-types">Primitive types;</a></li>
<li><a href="#constant-literals">Constant literals;</a></li>
<li><a href="#composite-types">Special types;</a></li>
<li><a href="#type-declaration">Type declaration;</a></li>
<li><a href="#range-type">Range type;</a></li>
<li><a href="#domain-type">Domain type;</a></li>
<li><a href="#constant-declarations">Constant declarations;</a></li>
<li><a href="#variable-declarations">Variable declarations;</a></li>
<li><a href="#modify-values">Modify values;</a></li>
<li><a href="#alphanumeric-type">Alphanumeric type;</a></li>
<li><a href="#type-inference">Type inference;</a></li>
<li><a href="#type-checking">Type checking;</a></li>
<li><a href="#boolean-type">Boolean type;</a></li>
<li><a href="#rational-numbers">Rational numbers;</a></li>

</ol>

<h4>Usability:</h4>
<ul>
<li>
<p>Bee is using a gradual typing system. We think dynamic typing is more fragile and prone to errors. Therefore Bee is a <em>strongly typed</em> language with type inference. That means any data is constrained by fixed <em> "data type"</em> rules.</p>
</li>
<li>
<p>Bee has predefined data types. You can create new data types based on predefined types using a type declaration. You can create sub-types or composite types having new constraints and rules that can improve data validation further.</p>
</li>
<li>
<p>A data type can be manipulated using rules and operators. You can have a variable of type: <em> Type</em>. To detect a data type of any variable you can use the introspection function type().
</li>
</ul>

<h2><a id="primitive-types"></a>Primitive Types</h2>
<p>Primitive data types are defined using one capital letter. This may be unusual in Computer Science but standard in Mathematics. Therefore Bee uses this convention.</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Alias</th>
<th>Code</th>
<th>Description + Default representation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>B</td>
<td>Boolean or 8 bit number, 0 = False, >= 1 True</td>
</tr>
<tr>
<td>Alpha</td>
<td>A</td>
<td>Alpha-numeric E-ASCII ('0'..'9') ('a'..'Z')</td>
</tr>
<tr>
<tr>
<td>Unicode</td>
<td>U</td>
<td>Unsigned 32 bit, max: U-FFFFFFFF (UTF32)</td>
</tr>
<tr>
<td>Rational</td>
<td>Q</td>
<td>Fix point representation number: like 1/2. Notation: Q(14,17)</td>
</tr>
<tr>
<td>Natural</td>
<td>N</td>
<td>Unsigned large positive integer 64 bit [0..+]</td>
</tr>
<tr>
<td>Integer</td>
<td>Z</td>
<td>Signed large integer 64 bit [-..+] Z(64)</td>
</tr>
<tr>
<td>Real</td>
<td>R</td>
<td>Double precision float 64 bit (-..+) R(64)</td>
</tr>
</tbody>
</table>

<h4>Notes:</h4>
<ul>
<li>Each data type has a default representation for literal, print &amp; output,</li>
<li>Output representation can be establish using a <em>format template</em>,</li>
<li>Using print with primitive type will create a specific representation,</li>
<li>Precision can be specified in parenthesis after the type: Z(32) = 32 bit integer,</li>
<li>Primitive data types are values allocated on the stack or in the registry.</li>
</ul>

<h2><a id="constant-literals"/>Constant Literals</h2>
<p>These are symbolic representations for primitive data types:</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Example</th>
<th>Type</th>
<th>Literal characters</th>
</tr>
</thead>
<tbody>
<tr>
<td>'a'</td>
<td>A</td>
<td>(+-) &amp; (0..9) &amp; (a..z) &amp; (A..Z)</td>
</tr>
<tr>
<td>'&Omega;'</td>
<td>U</td>
<td>(&Delta; &Lambda; &Phi; &Gamma; &Psi; &Omega; &Sigma; &Pi; &pi; &perp; ǁ &alpha; &beta; ɣ &epsilon; &delta; &mu; &omega; ...)</td>
</tr>
<tr>
<td>"str"</td>
<td>S</td>
<td>(&forall; UTF8)</td>
</tr>
<tr>
<td>0b0,0b1</td>
<td>B</td>
<td>(0,1) &amp; B</td>
</tr>
<tr>
<td>1234567890</td>
<td>N</td>
<td>(0,1,2,3,4,5,6,7,8,9)</td>
</tr>
<tr>
<td>+0</td>
<td>Z</td>
<td>(-+) &amp; (0,1,2,3,4,5,6,7,8,9)</td>
</tr>
<tr>
<td>'a','b'</td>
<td>A</td>
<td>ASCII (0x00..OxFF)</td>
</tr>
<tr>
<td>U+FFFF</td>
<td>U</td>
<td>(U+) &amp; (0,1,2,3,4,5,6,7,8,9) &amp; ABCDEF</td>
</tr>
<tr>
<td>U-FFFFFFFF</td>
<td>U</td>
<td>(U-) &amp; (0,1,2,3,4,5,6,7,8,9) &amp; ABCDEF</td>
</tr>
<tr>
<td>0.05</td>
<td>R</td>
<td>(-.) &amp; (0,1,2,3,4,5,6,7,8,9)</td>
</tr>
<tr>
<td>-1/2</td>
<td>Q</td>
<td>(-/) &amp; (0,1,2,3,4,5,6,7,8,9)</td>
</tr>
<tr>
<td>1E10</td>
<td>R</td>
<td>(-1E)&amp; (0,1,2,3,4,5,6,7,8,9)</td>
</tr>
<tr>
<td>1e10</td>
<td>R</td>
<td>(-1e)&amp; (0,1,2,3,4,5,6,7,8,9)</td>
</tr>
</tbody>
</table>

<p><b>note</b></p>
<ul>
<li>primitive types are ordered and can be compared,</li>
<li>primitive literals are identical to themselves,</li>
<li>primitive variables are identical to themselves.</li>
</ul>

<h2><a id="special-types"/>Special types</h2>
<p>Special types have an alias starting with capital letter. These types are embeded in the language and contribute to language coherence. All these types are actually references to memory structures:</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>Alias</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Complex</td>
<td>C</td>
<td>Double precision pair of double float numbers (9r+9j)</td>
</tr>
<tr>
<td>String</td>
<td>S</td>
<td>UTF8 encoded double quoted string "&alpha; &beta; ɣ &epsilon; &delta; &mu; &omega;"</td>
</tr>
<tr>
<td>Date</td>
<td>D</td>
<td>"DD/MM/YYYY"</td>
</tr>
<tr>
<td>Time</td>
<td>T</td>
<td>"hh:mm,ms"</td>
</tr>
<tr>
  <td>Lambda</td>
  <td>L</td>
  <td>Lambda expression or function.</td>
</tr>
</tbody>
</table>


<h2><a id="collection-types"></a>Collection types</h2>
<p>Bee define a collection literal using a special notation based on brackets. These types are going to be explained later in another page. We mention these types here because they represent types.</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>delimiter</th>
<th>collection types</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td>List</td>
</tr>
<tr>
<td>[]</td>
<td>Array / Matrix</td>
</tr>
<tr>
<td>{}</td>
<td> Set / Map / Object / Ordinal</td>
</tr>
</tbody>
</table>

<h4>Notes:</h4>
<ul>
<li>All collections are actually references,</li>
<li>Collection elements can be references or native types,</li>
<li>Elements of collection are separated by comma,</li>
<li>Pair of values are separated by columns ":"</li>
</ul>

<h2><a id="type-declaration"/>Type declaration</h2>
<p>User can define type alias using operators ":" and sub-types using operator "&lt;:" (inheritance). Usr can specify type of variables explicit usin operator &isin;</p>

<pre><code class="language-bee">** declare new type alias
type Type_Identifier: type_descriptor &lt;: super_type;

** declare variables using type alias
new var_name &isin; Type_Identifier;

** declare many variables using type alias
new var_name, var_name ... &isin; Type_Identifier;
</code></pre>


<h4>Notes:</h4>
<ul>
<li>User defined types are starting with capital letter;</li>
<li>User defined super-types are usually composite types;</li>
<li>User defined sub-types are usually domains of values;</li>
</ul>

<h2><a id="range-type"/>Range Type</h2>

<p>A <em>range</em> is a notation that designate a sub-set of consecutive  integer numbers between two limits: lower limit and upper limit included in round parenthesis and separated by two dots (..) or (!).</p>

<h4>Syntax:</h4>

<pre class="language-our">
range ::= (min..max);
range ::= (min.!max); -- exclude upper limit
range ::= (min!.max); -- exclude lower limit
</pre>


<h4>Notes:</h4>
<ul>
<li>Both limits are included in range by default</li>
<li>Upper or lower limits can be excluded using "!"</li>
<li>Range notation can be open at one end or both ends</li>
<li>Open lower limit is symbolic (-) with no number</li>
<li>Open upper limit is symbolic (+) with no number</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-bee">#integer domain
rule main:
  print (0..5); -- 0,1,2,3,4,5
  print (0.!5); -- 0,1,2,3,4
  print (0!.5); -- 1,2,3,4,5

  pass if  32667 &isin; (0..+); -- expect to pass
  pass if -32668 &isin; (-..0); -- expect to pass
return;
</code></pre>

<p>Ranges can use symbols that are ASCII or Unicode. In this case the symbols must be included in single quotes: 'X' or use U+ notation:</p>

<h4>Example:</h4>

<pre><code class="language-bee">** sub-type declarations
type  .Digit:    ('0'..'9')       &lt;: Z;
type  .Capital:  ('A'..'Z')       &lt;: A;
type  .Lowercase:('a'..'z')       &lt;: A;
type  .Latin:    (U+0041..U+FB02) &lt;: U;

rule main:
  ** following statements should pass
  pass if '0' &isin; Digit;
  fail if 'x' &isin; Capital;
  pass if 'X' &isin; Capital;
  pass if 'e' &isin; Latin;
return;
</code></pre>


<h2><a id="domain-type"/>Domain Type</h2>

<p>Domain is very similar to range except a domain has a ratio. This is the difference, the numbers are not integers, can be fractional or Q umber.</p>

<pre><code class="language-bee">
type Domain: (min..max:ratio)  &lt;: Super_Type;
</code></pre>

<h4>Examples:</h4>

<pre><code class="language-bee">** generate rational numbers
print (0..1:1&\4); -- 0&\4, 1&\4, 2&\4, 3&\4, 1

** generate float numbers
print (0..1:0.25); -- 0.00, 0.25, 0.50, 0.75, 1.00
</code></pre>

<h2><a id="constant-declarations"></a>Constant declarations</h2>
<p>Constants literals bound to identifiers using keyword "set".</p>

<pre><code class="language-bee">** using explicit type
set constant_name: constant_literal &isin; type_name;

** using implicit type
set constant_name := constant_literal;
</code></pre>


<h4>Notes:</h4>
<ul>
<li>Unfortunate English is using "set" to define a sequence,</li>
<li>In Bee we use "set" keyword to setup a constant not a sequence,</li>
<li>Constant initial value can be assigned using operator ":=" or "=",</li>
<li>Constants can be public, private or local,</li>
<li>Public constants are defined using prefix ".",</li>
<li>Local constants are defined in a local scope.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-bee">#define symbol constants
set forall1: U+2200     &isin; A; -- Symbol: &forall;
set forall2: U-00002200 &isin; U; -- Symbol: &forall;
</code></pre>


<h4>Note:</h4>
<ul>
<li>After U+ compiler is expecting 4 hexadecimal symbols;</li>
<li>After U- compiler is expecting 8 hexadecimal symbols;</li>
</ul>

<h2><a id="variable-declarations"/>Variable declarations</h2>
<p>Variables are defined using type inference and these operators:</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>operator</th>
<th>purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>&isin;</td>
<td>declare variable/element type</td>
</tr>
<tr>
<td>:</td>
<td>define | block start | pair up operator </td>
</tr>
<tr>
  <td>:</td>
  <td>set initial value (require type in declarations) </td>
</tr>
<tr>
<td>:=</td>
<td>type inference | share a reference | assign operator</td>
</tr>
<tr>
<td>::</td>
<td>deep copy | duplicate object | cloning operator</td>
</tr>
</tbody>
</table>

<h4>Notes:</h4>
<ul>
<li>Symbol ":" can be used to define a type or set initial value or type for a variable or parameter.</li>  
<li>Symbol ":" can be used as pair-up operator for arguments and map pairs.</li>
<li>Symbol ":=" can can be used to define or mutate the value of variables or parameters.</li>
<li>Symbol "<:" used in declarations is used to indicate a supertype,</li>
</ul>
<pre><code class="language-bee">** primitive variable declarations with type
new var_name &isin;  type_name; -- declaration only type without initial value
new var_name: value &isin;  type_name; -- declaration with initial value and type

** Variable declaration using type inference
new var_name := expression; -- expression ":=" do not require type hint ("&isin;").

** Multiple variables can be define in one single line using comma separator:
new var1, var2 ... &isin;  TypeName;   -- default initial values
new var1, var2 ... := Expression; -- use type inference for all initial values

** Initialize multiple variables, of the same type (type is required)
new var1:con1, var2:con2 ... &isin; TypeName;
</code></pre>


<h2><a id="modify-values"/>Modify values</h2>
<p>One can modify variables using <em>alter</em> statement.</p>

<h4>Example:</h4>
<pre><code class="language-bee">#fragment of code

new a:10, b:0 &isin; Z; -- initialize two variables
let b := a + 1;   -- modify b using binding operator :=
let b += 1;       -- modify b using modifier +=
expect b = 12;    -- check if b has proper value
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Multiple variables can be modified all at once when separated by comma;</li>
<li>Following operators are called modifiers and can change value of a variable:</li>
<ul>
<li>{":=","::"} </li>
<li>{"+=","-=","&\=","*=","^=","%=", "*=", "/=", "√="}</li>
</ul></ul>

<h4>Examples:</h4>
<pre><code class="language-bee">** declare a public constant
set .PI: 3.14 &isin; R;

rule main:
  ** declare a single variable
  new a   &isin; Z; -- Integer

  ** declare multiple variables
  new (x,y):0 &isin; R; -- Double
  new (q,p):0 &isin; L; -- Logic

  ** using modifiers
  let a := 10; -- modify value of: a == 10
  let a += 1;  -- increment value of: a == 11
  let a -= 1;  -- decrement value of: a == 10

  ** modify two variables using one single constant
  let x, y := 10.5;

  ** modify two variables using two constants
  let q, p := True, False;

  ** swapping two variables
  let p, q := q, p;
return;
</code></pre>

<h2><a id="type-conversion"/>Type conversion</h2>
<p>When data type mismatch you must perform explicit conversion.</p>
<ul>
<li>Explicit conversion is using a symbolic operator: ":&gt;"</li>
<li>This is unsafe operation. A range check is recommended before conversion;</li>
<li>Data precision may suffer. Some decimals may be lost;</li>
<li>If data do not fit in the new type, the overflow exception is raised.</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-bee">** data conversion
rule main:
   new a:0, b:20 &isin; Z;
   new v:10.5, x:0.0 &isin; R;
** explicit conversion
   let a:=v :&gt; N;
   print a; -- truncated to 10
** explicit conversion
   let x := b :&gt; R;
   print x; -- expect 20.00
return;
</code></pre>


<h4>Notes:</h4>
<ul>
<li>making conversion will copy value not reference</li>
<li>conversion to same data type is equivalent to copy "::"</li>
</ul>

<h2><a id="alphanumeric-type"/>Alphanumeric type</h2>
<p>Bee define A as single UTF-8 code point with representation: U+HH</p>
<pre><code class="language-bee">
rule main:
  new a, b &isin; A; -- ASCII
  new x, y &isin; B; -- Binary integer
  let a :='0';     -- ASCII symbol '0'
  let x := a :&gt; B; -- convert to binary 30
  let y := 30;     -- decimal code for '0'
  let b := y :&gt; A; -- convert to ASCII symbol '0'
return;
</code></pre>


<h2><a id="type-inference"/>Type inference</h2>
<p>You can use symbol ":=" to initialize variables using type inference.</p>
<pre><code class="language-bee">** declare constants
set i := 4;   -- integer constant
set r := 2.5; -- real constant
set q := 1&\8; -- rational constant
** declare variables
new x := 0;   -- integer number
new y := 0.0; -- real number
new z := 0\1; -- rational number
</code></pre>

<h2><a id="type-checking"/>Type checking</h2>
<p>We can use variable type to validate expression type.</p>

<pre><code class="language-bee">** using type inference
rule main:
  new a := 0;   -- integer variable
  new b := 0.0; -- real variable

  let a:= 10.5; -- error: explicit conversion is required
return;
</code></pre>

<p>You can use operator "&isin;" to verify data type:</p>
<pre><code class="language-bee">
rule main:
  new a := 0 &isin; Z;

  ** expected: Integer
  expect a &isin; Z;
return;
</code></pre>


<h2><a id="boolean-type"></a>Boolean type</h2>
<p>Boolean type is Bee is native numeric of type B. However we also implement native two constants True, False that are publicly available in core library</p>

<pre><code class="language-bee">
** overwrite the default values
set False = 0; 
set True  = 1; 
</code></pre>

<p>Printing native Boolean values is going to print numbers. Type B can support a number between 0b0 and 0b00000001. Therefore printing this type is done using notation 0b0 and 0b1.</p>
<pre><code class="language-bee">
** printing Boolean values
rule main:
  print False; -- 0b0
  print True;  -- 0b1
return;
</code></pre>

<p>You can convert B to a number, safely. You can convert a number to B explicit using cast operator: <code>number :&gt; B. </code>The number will loose all it's significance and become 0b1 or 0b0.</p> 


<h3>Logic operations</h3>
<p>Bee uses several familiar logic operators from mathematics:</p>
<ul>
<li>&not; - equivalent "not"</li>
<li>∧ - equivalent "and"</li>
<li>&or;  - equivalent "or"</li>
</ul>
<p>Precedence: { &not;, ∧, &or; }. Symbol &not; will apply first, symbol &or; will apply last.</p>

<p><b>bitwise</b></p>
<p>In Bee we define special operators to perform bitwise operations. One opperator is overwrite: &oplus;. This operator (xor) can operate on both, logical values or expressions and also on integer numbers.</p>

<ul>
<li>~ (not)</li>
<li>&amp; (and)</li>
<li>| (or)</li>
<li>&oplus; (xor)</li>
</ul>

<pre><code class="language-bee"># bitwise operations
print 4 | 3; -- out:7 is because 100 | 011 = 111 = 7;
print ~4;    -- out:3 is because: 100 ~  100 = 011 = 3;
print 4 &amp; 7; -- out:4 is because: 100 &amp; 111 = 100 = 4;
print 4 &oplus; 4;  -- out:0 is because: 100 &oplus; 100 = 000 = 0;
print 1 &lt;&lt; 2;  -- out:2 is because: 001 &lt;&lt; 2   = 100 = 4;
print 6 &gt;&gt; 2;  -- out:1 is because: 110 &gt;&gt; 2   = 001 = 1;
</code></pre>

<h4>Other operators</h4>

<p>Comparison operators will create a Boolean response: 1 = True or 0 = False. Also, the equivalent and belonging operators will create a Boolean response. You can combine them to create Boolean expressions.</p>

<ul>
<li>comparison ( &asymp;, =, &ne;, &equiv;, !&equiv;,  &gt;, &lt;, &le;, &ge;)</li>
<li>equivalents (==, !=, <=, >=)</li>
<li>belonging ( &isin;, !&isin; )</li>
</ul>

<h4>Example:</h4>
<pre><code class="language-bee">
rule main:
  new (x, y):4 &isin;  Z; -- primitive integer
  ** value comparison
  print x = 4;  -- 1 (equal)
  print x &equiv; 4;  -- 1 (identical)
  print x = y;  -- 1 (equal)
  print x &equiv; y;  -- 1
  print x &ne; 5;  -- 1 (different)
  print x!&equiv; 5;  -- 1 (not identical)

  ** reference ordering
  print x &ge; y;  -- 1: x and a are actually equal
  print x &ge; 4;  -- 1: greater or equivalent to 4
  print x &le; 4;  -- 1: less than or equivalent to 4
  print x &gt; 4;  -- 0: not greater than 4
  print x &lt; 4;  -- 0: not less than 4


  ** arithmetic expressions have primitive results
  print x - 4 = 0; -- 1
  print x - 4 &equiv; 0; -- 1
return;
</code></pre>


<p><b>singleton</b></p>
<p>Primitive types are unique. That means they are equivalent. A literal or constant is equivalent to another literal having the same value.</p>

<pre><code class="language-bee">** primitive values are singleton
print  1  &equiv;  1;  -- 1
print "s" &equiv; "s"; -- 1

** alternative operator have the same significance
print  1  == 1;  -- 1
print "s" == "s"; -- 1
</code></pre>

<p><b>Precedence:</b></p>
<p>Logic operators have greater precedence than comparison operators.</p>

<h3><a id="logical-expression"/>Logical expression</h3>
<p>Logical expression have value { 0 = False, 1 = True }</p>
<pre><code class="language-bee">
** define constants based on Boolean values
set f: False;
set t: True;

rule main:
  ** expressions with single operant
  print f; -- 0
  print &not; t; -- 0

  ** expressions with two operands
  print (f = t); -- 0
  print (f &equiv; t); -- 0
  print (f &ne; t); -- 1
  print (f &lt; t); -- 1
  print (f &gt; t); -- 0
  print (f ∧ t); -- 0
  print (f &or;  t); -- 1
  print (f &oplus; t); -- 1
return;
</code></pre>


<h4>Notes:</h4>
<ul>
<li>Operators { &not; } is unary operator;</li>
<li>Operators { ∧, &or; } are also bitwise operators;</li>
<li>Operators { &not;, &oplus; } are also bitwise operators;</li>
<li>Operators { &laquo;, &raquo; } are bitwise operators;</li>
</ul>

<p><b>coercion</b>&nbsp;Any numeric expression  can be converted to a logic value using coercion operator ":&gt;" (easy to memorize if you think is like an arrow).</p>

<pre><code class="language-bee">
set (a: 0.0, b: 1.5) &isin; R;
rule main:
  new (x, y) &isin; B;

  let x := a :&gt; B; -- 0
  let y := b :&gt; B; -- 1
return;
</code></pre>


<h4>Notes:</h4>
<ul>
<li>Real number is truncated before conversion to Boolean;</li>
<li>A string: "Yes", "yes", "True", "true", "On","on", "T", "t" or "1" convert to: True = 1</li>
<li>A string: "No", "no", "False", "false", "Off","off", "F", "f" or "0" convert to: False = 0</li>
</ul>

<p><b>design</b></p>
<pre><code class="language-bee">** logical values are numeric
print True  &equiv; 1;  -- 1
print False &equiv; 0;  -- 1

** logical values do not compute
print False - True; -- Error
print True  + True; -- Error

** Null value is not True
print Null  &equiv; True   -- 0
** Null value is not False
print Null  &equiv; False  -- 0
</code></pre>


<h2><a id="type-inference"/>Type inference</h2>

<p>Type inference is a logical deduction of data type from constant literals.</p>

<h4>Page bookmarks:</h4>
<ul>
<li><a href="#default-types">Default types</a></li>
<li><a href="#ti-composite-types">Composite types</a></li>
<li><a href="#parameter-types">Parameter types</a></li>
</ul>

<h3><a id="default-types"/>Default types</h3>
<p>Each literal has associated a default type, induced by operators {":=", "::"}.</p>
<pre><code class="language-bee">** string expressions
new c := 'a'     ;  -- type = A
new s := '&isin;'    ;  -- type = U
new s := "str"   ;  -- type = S
** numeric expressions
new i := 0;    -- type = Z
new j := 0.50; -- type = R
** define synonyms for logic constants
set f := False; -- type B
set t := True;  -- type B
** multiple variables get same value
new (x, y, z) := 5; -- type = Z for all
** multiple variables get multiple values
new int, rea := -4, 4.44;
print type(int); -- Z
print type(rea); -- R
</code></pre>

<h3><a id="ti-composite-types"></a>Composite Types</h3>
<p>Composite structures are using () [] and {} to create different data types. Next you can study some examples. We wil explain later all these types: List, Map, Array, Object. All of these are also called Bee collections.</p>
<pre><code class="language-bee">** boxed integer (type = Z)
new i := [10]; -- array of one value = 10!
** array with capacity of 4 integers: Z
new d := [1,2,3,4];
** array with capacity of 10 real numbers: R = 0.00
new e := [0.00](10);
** list of one value (Z)
new a := (1);
** list of integers (Z)
new b := (1,2);
** list of symbols (type = A)
new l := ('a','b');
** list of Unicode symbol (type = U)
new u := ("&Delta;", "&Lambda;", "&Gamma;");
** 2d matrix with capacity of 10x10 real numbers: R
new m := [0.00](10,10);
** 3d matrix with capacity of 10x10x10 reals: R = 0.00
new m := [0.00](10,10,10);
** data set of 4 integers: Z
new s := {1,2,3,4};
** hash map of (Integer: String)
new c := {1:"storage",2:"string"};
** object with two attributes: name &isin; S, age &isin; Z
new b := {name:"Goliath", age:30};
</code></pre>

<h3><a id="parameter-types"/>Parameter types</h3>
<p>When we define parameters we can use type inference only for optional parameters. Mandatory parameters must have type declaration using &isin; symbol. If default value is not specified the parameter will have defailt zero initial value.</p>

<p><b>Optional Parameters:</b></p>
<pre><code class="language-bee">** in rule foo, parameters a, b are optional.
rule foo(a: 0 &isin; Z, b: 0 &isin; Z) =&gt; (r &isin; Z):
  let r := a + b;
rule;

rule main:
  print foo();    -- 0
  print foo(1);   -- 1
  print foo(1,2); -- 3
return;
</code></pre>


<p><b>Multiple parameters:</b></p>
<pre><code class="language-bee">** parameters: a, b are mandatory, c is optional.
rule foo(a, b, c:0 &isin; Z) =&gt; (r &isin; Z):
  let r := a + b + c;
return;

rule main:
  print foo(1,2);   -- 3
  print foo(1,2,3); -- 6
  print foo(1);     -- Error: expected 2 arguments
return;
</code></pre>


<p><b>Pass arguments by name:</b></p>
<p>We can use parameter name and pair-up symbol ":" for argument value.</p>
<pre><code class="language-bee">** rule with optional parameter (c)
rule bar(a, b, c:0 &isin; Z) =&gt; (result &isin; Z):
  let result := a+b+c;
return;
** observe we use pair-up ":" to give value for each argument
rule main:
  print bar( 1, 1 );    -- print 2 because c = 0
  print bar( a:1, b:1, c:1 ); -- print 3 because c = 1
return;  </code></pre>


<h2><a id="rational-numbers"/>Rational numbers</h2>
<p>In mathematics rational number is any number that can be expressed as the fraction p/q of two integer numbers: numerator "p" of type <em>integer</em> and a non-zero denominator "q" of type <em>natural</em>&gt; 0. <br />Since "q" may be equal to 1, every binary integer is also a rational number.</p>

<p><b>Note:</b>&nbsp;Q numbers are approximated numbers.</p>
<ul>
<li>Default precision for Q numbers is $precision: 10⁻⁵ = 0.00001</li>
<li>Default precision can be set using: $precision:x; global constant</li>
<li>Operator "&asymp;" is using the precision if the operator "&plusmn;" is not used;</li>
</ul>
<p>Other precision constants:</p>
<ul>
<li>$deci  := 1d = 10⁻&sup1;</li>
<li>$centi := 1c = 10⁻&sup2;</li>
<li>$mili  := 1m = 10⁻&sup3;</li>
<li>$micro := 1&mu; = 10⁻⁶</li>
</ul>

<p><b>Literal Notation:</b>&nbsp;p\q</p>
<p>It can be used with type inference to create Q numbers:</p>

<h4>Example:</h4>
<pre><code class="language-bee">
new x: 0     &isin; Q; -- 0
new a: 1\2   &isin; Q; -- 0.5
new b: 1\4   &isin; Q; -- 0.25
new c: 1\8   &isin; Q; -- 0.125
new d: 1\16  &isin; Q; -- 0.062
new e: 1\32  &isin; Q; -- 0.031
</code></pre>

<h4>Note:</h4>
<ul>
<li>The inch is a unit of length in the British imperial and United States</li>
<li>It is equal to 1\36 yard or 1\12 of a foot</li>
<li>One inch is divided in 1\2, 1\4, 1\8, 1\16 and 1\32</li>
</ul>
<p>See also:&nbsp;<a href="https://en.wikipedia.org/wiki/Rational_data_type" rel="nofollow">wikipedia</a></p>

<h3>Q Notation</h3>
<div class="alert alert-secondary">Evaluation or rational number has a magnitude and precision defined by the user. Q numbers are defined using <em> "fixed point arithmetic"</em>  This is a way of computing fractional numbers and control the precision.</div>
<ul>
<li>
<p>Qm.n is m+n+1 bit signed integer container with n fractional bits.</p>
</li>
<li>
<p>Qm is a m+1 bit signed integer containing 0 fractional bits.</p>
</li>
<li>
<p>number of bits = m+n+1</p>
</li>
<li>
<p>precision is 2⁻ⁿ</p>
</li>
<li>
<p>range is [-(2ᵐ)..(2ᵐ-2⁻ⁿ)]</p>
</li>
</ul>

<p><b>For example:</b>&nbsp;Number format "Q5.2" can store in range (-32.00..31.75) on 8 bits.</p>
<ul>
<li>with precision of 2⁻&sup2; = 1\4 = 0.25</li>
<li>from value: -2⁵ = -32.00</li>
<li>to value: 2⁵ - 2⁻&sup2; = 32 - 0.25 = 31.75</li>
</ul>
<pre><code class="language-bee">
new v &isin; Q5.2;
let v := -32;   -- minim value
let v := 31.75; -- maxim value
</code></pre>

<p>See also:&nbsp;<a href="https://en.wikipedia.org/wiki/Q_(number_format)" rel="nofollow">wikipedia</a></p>

<h3>Typical Q numbers</h3>
<p>Next I have predefined some numbers for orientation.</p>

<table class="table table-bordered table-striped">
<thead>
<tr>
<th>rezolution -></th>
<th>1\4 &asymp;</th>
<th>1\8 &asymp;</th>
<th>1\16 &asymp;</th>
<th>1\32 &asymp;</th>
<th>1\64 &asymp;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="color:purple">↓ memory space</td>
<th style="color:purple">&plusmn;0.25 </th>
<th style="color:purple">&plusmn;0.125</th>
<th style="color:purple">&plusmn;0.062</th>
<th style="color:purple">&plusmn;0.031</th>
<th style="color:purple">&plusmn;0.015</th>
</tr>
<tr>
<td>8 bytes</td>
<td>Q(5.2 )</td>
<td>Q(4.3 )</td>
<td>Q(3.4 )</td>
<td>Q(2.5 )</td>
<td>Q(1.6 )</td>
</tr>
<tr>
<td>16 bytes</td>
<td>Q(13.2 )</td>
<td>Q(12.3 )</td>
<td>Q(11.4 )</td>
<td>Q(10.5 )</td>
<td>Q(9.6  )</td>
</tr>
<tr>
<td>32 bytes</td>
<td>Q(29.2 )</td>
<td>Q(28.3 )</td>
<td>Q(27.4 )</td>
<td>Q(26.5 )</td>
<td>Q(25.6 )</td>
</tr>
<tr>
<td>64 bytes</td>
<td>Q(61.2 )</td>
<td>Q(60.3 )</td>
<td>Q(59.4 )</td>
<td>Q(58.5 )</td>
<td>Q(56.6 )</td>
</tr>
<tr>
<td>128 bytes</td>
<td>Q(125.2)</td>
<td>Q(124.3)</td>
<td>Q(123.4)</td>
<td>Q(122.5)</td>
<td>Q(121.6)</td>
</tr>
</tbody>
</table>

<p><b>Note:</b>&nbsp;r &asymp; is the approximate resolution.</p>

<h4>Examples:</h4>
<p>A very large number with high resolution on 64 bit:</p>

<p><b>Q(50.12)</b></p>
<ul>
<li>Min: -1125899906842624</li>
<li>Max: +1125899906842623</li>
<li>Res: 0.000244140625</li>
</ul>
<p>A number on 32 bit with resolution = 0.0005:</p>

<p><b>Q(20.11)</b></p>
<ul>
<li>Min: -1048576</li>
<li>Max: 1048575</li>
<li>Res: 0.00048828125</li>
</ul>

<h3>Default Q number</h3>

<p><b>Q(14.17)</b></p>
<p>Bee is using default Q type for type inference, when precision is not specified. Default Q number has precision 10⁻⁵ = 2⁻&sup1;⁷ &asymp; 0.00001 and occupy 32 bit. It's a relative small number. For larger numbers you must specify the resolution and capacity.</p>

<h4>Range:</h4>

<ul>
<li>Min: -16384</li>
<li>Max: +16383</li>
<li>Res: 0.0000076</li>
</ul>

<h4>Fraction:</h4>

<ul>
<li>Smallest fraction: 1\10000</li> 
<li>Largest fraction: 32766\2</li>
</ul>

<h3>Approximate comparison</h3>

<p>Rational numbers and other numbers can be compared using "&asymp;" instead of "=". Bee can be used to make aproximative computations and logic expressions based on precision.</p>

<ul>
<li>Operator "&asymp;" can be used to compare two numbers using default precision;</li>
<li>Operator "&asymp;" can be used with "&plusmn;" to overwrite default precision;</li>
</ul>

<h4>Example:</h4>
<p>In next example b = 0.33(3), delta = (b - a) = 0.083</p>
<pre><code class="language-bee">** override default precision
set $precision := 0.01;

rule main:
    new a := 0.25; -- real
    new b := 1\3;  -- rational O.33(3)
    ** using specified precision 0.01
    print (a &asymp; b); -- 0B0: (False, 0.033 - 0.25 = 0.08 )

    ** using specified precision:
    print (a &asymp; b &plusmn; 0.01);  -- 0b0 (False)     
    print (a &asymp; b &plusmn;  0.05); -- 0b0 (False)    
    print (a &asymp; b &plusmn;  0.10); -- 0b1 (True)
return
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Operator "\" has high priority in expressions;</li> 
<li>Rational numbers improve computation efficiency;</li>
</ul>

<h4>Conversion</h4>

<p>Rational numbers are similar to complex numbers. The calculation of rational number is postponed until is necesary in expressions and it can produce different results depending on the precision.</p>

<ul>
<li>Conversion from rational number to real is implicit;</li>
<li>Conversion from real to rational is explicit;</li>
</ul>

<pre><code class="language-bee">** execute conversion
rule main:
    new a := 0.25; -- real
    new b := 1\4;  -- rational

    ** explicit conversion R :&gt; Q
    expect a &ne; b; -- not equal, type mismatch
    expect a &asymp; b; -- values match, aproximation
    expect a &equiv; b; -- implicit conversion, match

    ** explicit conversion R :&gt; Q
    new c := a :&gt; Q; 
    expect c = b; -- type & value match
    expect c &equiv; b; -- type & value match

    ** implicit conversion Q :&gt; R
    new r := c &isin; R;
    expect c = 0.25;
return
</code></pre>

<p><b>Read next:</b>
<a href="/bee/control/">Control</a></p>
<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>