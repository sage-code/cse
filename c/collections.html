<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Data structures explained for C programming.">
  <meta name="author" content="Your Name">
  <meta name="keywords" content="C, data, array, struct, pointer, linked list, collections">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C Collections</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <link rel="icon" type="image/png" href="/images/favicon.ico">
  <!-- Prism Highlighter -->
  <link rel="stylesheet" href="/prism.css">
  <script src="/prism.js"></script>
  <link rel="stylesheet" href="/sage.css">
</head>
<body>
<div class="container">

<header class="row">
  <div class="col">
    <a href="https://sagecode.pro"><img src="/images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
  </div>
  <div class="col bottom-right">
    <a href="/index.html" rel="nofollow">index</a><--
  </div>
</header><hr>

<h1>C Collections</h1>
<div class="alert alert-secondary shadow-sm">
Collections in C are data structures that group multiple values together. Unlike some higher-level languages, C doesn't have built-in "collections" but relies on fundamental types like arrays and structs, along with pointers, to build more complex data structures.
</div>

<p>This page explores the foundational building blocks of data collections in C, from simple arrays to complex structures like linked lists.</p>

<ul> 
  <li><a href="#arrays">Arrays</a></li>
  <li><a href="#structs">Structs</a></li>
  <li><a href="#pointers">Pointers</a></li>
  <li><a href="#linked-lists">Linked Lists</a></li>
  <li><a href="#dynamic-arrays">Dynamic Arrays</a></li>
</ul>

<hr>
<h2><a id="arrays"></a>Arrays</h2>
<p>An array is a collection of elements of the same data type, stored in contiguous memory locations. You access individual elements using an index, which starts at <code>0</code>.</p>

<h4>Syntax:</h4>
<pre><code class="language-c">
// Declaration with a fixed size
int numbers[5];

// Declaration and initialization
int primes[] = {2, 3, 5, 7, 11};

// Accessing an element
int first_prime = primes[0];
</code></pre>

<h4>Example:</h4>
<p>This example declares an array of integers, initializes it, and then iterates through it to print each element.</p>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int scores[3] = {95, 88, 92};
    printf("Scores:\n");
    for (int i = 0; i < 3; i++) {
        printf("Score at index %d: %d\n", i, scores[i]);
    }
    return 0;
}
</code></pre>

<h4>Expected Output:</h4>
<pre class="language-output">
Scores:
Score at index 0: 95
Score at index 1: 88
Score at index 2: 92
</pre>

<h4>Notes:</h4>
<ul>
  <li>Arrays in C have a fixed size after declaration.</li>
  <li>Accessing an element outside the array's bounds (e.g., <code>scores[3]</code>) leads to undefined behavior.</li>
</ul>

<hr>
<h2><a id="structs"></a>Structs</h2>
<p>A struct (structure) is a composite data type that groups variables of different data types under a single name. Structs are fundamental for creating complex data types in C.</p>

<h4>Syntax:</h4>
<pre><code class="language-c">
// Struct definition
struct Person {
    char name[50];
    int age;
    float height;
};

// Declaring a struct variable
struct Person p1;

// Accessing struct members
strcpy(p1.name, "Alice");
p1.age = 30;
p1.height = 1.65;
</code></pre>

<h4>Example:</h4>
<p>Here, we define a <code>Car</code> struct and create two instances of it, accessing and printing their members.</p>
<pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Car {
    char brand[20];
    int year;
    float price;
};

int main() {
    struct Car car1;
    strcpy(car1.brand, "Toyota");
    car1.year = 2020;
    car1.price = 25000.00;

    struct Car car2 = {"Honda", 2022, 30000.50};

    printf("Car 1: %s, %d, $%.2f\n", car1.brand, car1.year, car1.price);
    printf("Car 2: %s, %d, $%.2f\n", car2.brand, car2.year, car2.price);
    
    return 0;
}
</code></pre>

<h4>Expected Output:</h4>
<pre class="language-output">
Car 1: Toyota, 2020, $25000.00
Car 2: Honda, 2022, $30000.50
</pre>

<hr>
<h2><a id="pointers"></a>Pointers</h2>
<p>Pointers are variables that store memory addresses. They are crucial for creating dynamic data structures and for efficient memory management in C. Pointers "point" to the location of other variables.</p>

<h4>Syntax:</h4>
<pre><code class="language-c">
int num = 10;
int *p;      // Pointer declaration
p = &num;    // Assigning the address of 'num' to 'p'

// Dereferencing the pointer to get the value
printf("Value: %d\n", *p); // Prints 10
</code></pre>

<h4>Pointers and Structs:</h4>
<p>When working with pointers to structs, you use the <code>-></code> operator to access members.</p>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

struct Point {
    int x;
    int y;
};

int main() {
    struct Point p = {10, 20};
    struct Point *ptr = &p;

    // Accessing members using the pointer
    printf("x: %d, y: %d\n", ptr->x, ptr->y);
    
    return 0;
}
</code></pre>

<hr>
<h2><a id="linked-lists"></a>Linked Lists</h2>
<p>A linked list is a fundamental dynamic data structure where elements are not stored in contiguous memory locations. Instead, each element (a "node") contains a value and a pointer to the next node in the sequence.  </p>

<h4>Anatomy of a Node:</h4>
<pre><code class="language-c">
struct Node {
    int data;
    struct Node* next; // Pointer to the next node
};
</code></pre>

<h4>Example:</h4>
<p>This example demonstrates how to create a simple singly linked list with three nodes.</p>
<pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

int main() {
    struct Node* head = (struct Node*)malloc(sizeof(struct Node));
    head->data = 1;
    head->next = NULL;

    struct Node* second = (struct Node*)malloc(sizeof(struct Node));
    second->data = 2;
    second->next = NULL;
    head->next = second; // Link the first node to the second

    struct Node* third = (struct Node*)malloc(sizeof(struct Node));
    third->data = 3;
    third->next = NULL;
    second->next = third; // Link the second node to the third

    // Traverse and print the list
    struct Node* current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");

    // Clean up memory
    free(head);
    free(second);
    free(third);
    
    return 0;
}
</code></pre>

<h4>Expected Output:</h4>
<pre class="language-output">
1 -> 2 -> 3 -> NULL
</pre>

<hr>
<h2><a id="dynamic-arrays"></a>Dynamic Arrays</h2>
<p>Unlike C's built-in static arrays, you can create dynamic arrays using pointers and memory allocation functions like <code>malloc()</code> and <code>realloc()</code>. This allows the array's size to be determined at runtime and resized as needed.</p>

<h4>Example:</h4>
<p>We'll create a dynamic array, add elements, and then resize it using <code>realloc()</code>.</p>
<pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int initial_size = 3;
    int* dynamic_array = (int*)malloc(initial_size * sizeof(int));

    if (dynamic_array == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    // Initialize elements
    for (int i = 0; i < initial_size; i++) {
        dynamic_array[i] = (i + 1) * 10;
    }

    // Print initial array
    printf("Initial array: ");
    for (int i = 0; i < initial_size; i++) {
        printf("%d ", dynamic_array[i]);
    }
    printf("\n");

    // Resize the array to a new size
    int new_size = 5;
    dynamic_array = (int*)realloc(dynamic_array, new_size * sizeof(int));
    if (dynamic_array == NULL) {
        printf("Memory reallocation failed!\n");
        return 1;
    }

    // Add new elements
    dynamic_array[3] = 40;
    dynamic_array[4] = 50;

    // Print resized array
    printf("Resized array: ");
    for (int i = 0; i < new_size; i++) {
        printf("%d ", dynamic_array[i]);
    }
    printf("\n");

    // Clean up memory
    free(dynamic_array);
    
    return 0;
}
</code></pre>

<h4>Expected Output:</h4>
<pre class="language-output">
Initial array: 10 20 30 
Resized array: 10 20 30 40 50 
</pre>

<hr>

<p><b>Read next:</b>
<a href="#">Memory Management</a></p>
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>